1、 TS + GraphQL + DI(依赖注入) + Decorator(装饰器) 编写 node 应用
  Next.js node框架
  TypeORM 数据库管理
  RESTful API
  GraphQL

2、移动端开发 与 web开发
  web 开发局限
    通过网络加载资源，初始化效率慢
    单线程模式容易阻塞渲染，体验不如 Native
    API能力有限
    JS是动态解析的语言，执行效率 比 预编译的语言低

  客户端开发局限
    动态性差，发版周期长
    开发成本高
    需要考虑 安卓 + IOS 一致性

  Hybird 混合应用
    JSBridge
      Native 与 JS 可以互相调用接口，缺点是 性能不如native、高级组件扩展能力缺失

    RN / Weex
      使用 JS引擎 调用 Native 组件，将react框架代码 转成 native 组件实现
      缺点有 样式采用的是css子集，复杂交互难以实现，native双端一致问题仍然存在

    flutter 
      自绘引擎，不再使用 native 组件

    PWA
      通过service worker缓存机智，离线加载资源
      后台驻留进程，service worker允许在关闭页面后继续运行
      消息推送
      类App体验
    
    PHA (小程序、快应用)
      PWA的标准尚未完善
  
3、css、svg

4、vscode 技巧
  参考：Debug(https://code.visualstudio.com/docs/editor/debugging)
  Iceworks(https://marketplace.visualstudio.com/items?itemName=iceworks-team.iceworks)

5、机器学习

6、weex性能优化实践

7、智能UI

8、TS
  JS现有的基本类型通过 类型注解 [: Type]
  数组类型的语法 [ Type[] ]
  对象类型通过 interface 描述
  函数类型
  类型推论: 如果没有明确指定类型，ts会依据类型推论规则推断出一个类型，如定义变量的时候
  类型别名 [ type 自定义名称 = Type ]
  扩展了 class 特性，新值 public、private、protected、readonly、abstract 抽象类
  扩展类型: any、联合类型(类型中的或操作)
  类型断言 [value as Type] : 要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可
    1. 联合类型可以被断言为其中一个类型
    2. 父类可以被断言为子类
    3. 任何类型都可以被断言为 any
    4. any 可以被断言为任何类型
    利用 3，4 双重断言可以将值改为任意其他类型
  字面量类: 类型别名 + 联合类型
  元组: 长度和类型固定的数组 let man: [string, number] = ['Tom', 25]
  枚举 enum : 字符串枚举、常数枚举
  范型 <T>: 类型系统里的 函数，通过传入类型参数得到一个具体的类型
    范型函数
    范型接口
    范型类
    内置的数组范型
  函数重载
  接口合并: 同名接口将会合并，但属性类型需唯一
  声明文件: 提供类型声明，常用于三方库或环境定义

9、多媒体技术

10、开发与部署代码

11、websocket node服务端实现

12、css布局

13、快速理解业务
  业务掌握程度
    1. 业务做的是什么？产品大图有吗？
    2. 业务的核心指标是什么？KPI 目标是什么，这些数字背后的含义是什么？要达成这些目
    标，业务策略是什么？
    3. 业务的用户是谁？流量怎么分层？占比多少？分别在业务中是怎样的定位？
    4. 业务的商业模式？靠什么吸引流量，盈利模式是怎样的？
    5. 我们做的页面是什么东西？为业务带来什么价值？要创造更多的价值，我们可以做什
    么？
  学习业务

14、vite
  es module: 浏览器原生支持了模块化，可以跳过webpack打包, 直接从服务端获取模块，并且可以按需加载

15、2020热门技术
  前端智能化
    imgcook
    pipcook
