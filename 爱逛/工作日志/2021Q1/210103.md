本周工作安排
  √ 排查直播间热卖推荐串商品问题 -德文
  爱逛号主页 -喜康 https://doc.qima-inc.com/pages/viewpage.action?pageId=299406102
  

本周完成情况
  周一 / 周二
    排查记录
      1、从会场页回退到直播间时，不需要重新获取宝贝袋数据，但会重新获取 hotGoods 上屏商品，并触发 handleList
        宝贝袋数据用的是 getter，存储在 直播间 page 下的 store 实例中
        不同直播间用的 store 不同，命名空间为 live-room-${ pageIndex }
      2、偶发 handleList 修改 goodsList 后，没有触发对 goodsList 的更新，from setHotGoods
        修改 热卖推荐商品 的获取方案，取消事件推送，改为watch监听，直接从 store.goodsList 获取
    解决方案
      goods-is-top 组件中增加对 store.goodsList 的监听，从中找到 热卖商品

  周三
  周四
  周五
  周六

本周复盘总结
  进度: 未延期 ｜ 延期 N 天
  质量: 出现线上问题 N 次，产品验收发现问题 N 个
  需要保持:
  需要提高:
  心得:

临时任务 & 下周计划
           
知识点记录
  小程序跳转


本周工作记录
  navigateTo
    保留当前页面，跳转到应用内的某个页面
    但是不能跳到 tabbar 页面
    navigateBack 可以返回到原页面
    会调用onHide() 页面周期函数

备忘录
  上周两个问题
    加完埋点后没有验证
    小程序bus发布后没有当天合进master
      计划周五bus发布元旦功能，周日追加埋点
      活动开始是在周一凌晨
      因为周五的bus没有在线上验证过。所以想等到验完再合进bus
      所以 周日的修改 是从 周五bus 迁出的分支而不是master，得到的 周日bus
      但是这个信息没有同步到其他成员，因此其他人在跟车时通常会从master迁分支，这样就容易造成冲突

      结论是：当天的bus上线后可以先合进master，即便有小问题也可以再迁出修复

  setHotGoods 没有触发watch
    vanx 在观察对象的时候，会 递归观察所有子属性
    修改观察对象的值时，新值也会被递归订阅
    对象类型在赋值时，递归比对新旧值 属性的个数、属性名、属性值 都相等时，才认为是相等，不触发订阅的 watcher

    定位的原因是: actions 提交 mutation 时，使用的值是 state 下的引用


  hooks:


  小程序的模块化方案
    小程序支持模块复用方式
      module.exports / reqiure 模块的导入导出
        小程序不支持直接引入 node_modules，使用方法有两种
          将依赖拷贝到项目路径下，这部分可以交给 webpack
          使用小程序的npm https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html

      小程序存在文件作用域，不同文件的同名变量互不影响，全局变量可挂载在 app实例 下

      WXML模版 import、include https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html

      behaviors https://developers.weixin.qq.com/miniprogram/dev/reference/api/Behavior.html
        类似于 mixins，可以将定义的 属性、数据、生命周期函数 合并进 引用他的组件 中
        组件可以引用多个 behavior，behavior 之间也可以相互引用
        同名覆盖规则 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html
          属性、方法、特殊生命周期(如onShareAppMessage) (覆盖)
            组件 > behavior
            靠后的 behavior > 靠前的 behavior
            父 behavior > 子 behavior 

          数据 (覆盖 / 合并): '引用类型' 进行递归合并, '常量类型' 进行覆盖, 覆盖规则为 (大的覆盖小的)
            组件 > 父 behavior > 子 behavior
            靠后的 behavior > 靠前的 behavior

          生命周期 (合并): 不会相互覆盖，而是在对应触发时机被逐个调用, 同名生命周期的执行顺序: 
            behavior -> 组件
            子 behavior -> 父 behavior
            靠前的 behavior -> 靠后的 behavior

        存在的一些问题
          不支持自定义字段如 store
          App、Page不能支持生命周期的复用 (Component 支持)
          Page 和 Component 引入同一个 behavior, 会导致 behavior 中提供给 Component 用的 生命周期函数 触发多次

    mixins 方案
      行为表现 和 覆盖规则 基本与 behaviors 一致
      优化点 (见behaviors 存在的一些问题)


  

