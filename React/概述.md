React 生命周期
  挂载
    * 组件的 constructor
    ？ getDerivedStateFromProps
    * render
      只返回需要渲染的东西
    * componentDidMount
      组件挂载完成时调用，此时可以拿到 DOM
      官方建议将异步请求放在这个阶段

  更新
    ？getDerivedStateFromProps
    * shouldComponentUpdate (nextProps, nextState) => boolean(是否触发重新渲染)
    * render
    ？getSnapshotBeforeUpdate (prevProps, prevState) 
    => componentDidUpdate (prevProps, prevState, snapshot)

  卸载
    componentWillUnmount
      清除定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作

setState 是异步还是同步
  视情况而定，在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的
  因为 合成事件和钩子函数 的调用顺序在 状态更新 之前，因此无法拿到 更新后的状态值

React 组件间通信
  props / props+回调 父子通讯
  context 组件树的跨层级通讯
  发布订阅模式 event
  全局状态管理工具 redux

React 组件/逻辑 复用
  mixin(官方弃用)
  高阶组件HOC (组件嵌套) 的两种实现方案
    属性代理
      高阶组件
    反向继承
  渲染属性
  hooks

reconcilation 更新策略: react的diff算法
  (1) 比较元素类型，相同进入(2), 不同舍弃重建
  (2) 比较元素属性，更新变化的属性，并调用 子节点的componentWillReceiveProps 传递新值
  (3) 更新子节点列表，key的作用是快速匹配新旧子节点是否相同，因此key仅需在同一个父元素下唯一
  (4) 从根节点开始往下递归重复以上操作

fiber 架构
  React16 版本之前 reconcilation(调和) 的方式是递归，之后采用 fiber 架构
  fiber 将 reconcilation 的过程拆分成很多小任务，可以根据浏览器当前帧是否空闲决定任务的暂停/恢复

Redux
  store 
  state
  action
  action creator
  reducer
  dispatch
