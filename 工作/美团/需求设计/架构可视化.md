需求文档 https://km.sankuai.com/page/1284402734
  1. 体现树形结构的包含关系
  2. 节点大小需要基于 叶子节点数量 体现, 无接口的服务面积记为1
  3. 节点间可能存在关联关系，需要体现

  矩形树图 自带 功能 1、2

测试数据
  // 数据结构 
  const INode = {
    id: "1",            // 字符串，节点id，唯一值 
    name: "节点名称",    // 字符串，用于展示
    type: "",           // 节点类型，0-应用 1-组织 2-...
    info: {},           // 节点信息
    children: [         // 数组，其子节点结构与 INode 一致
      {
        id: "1_1",
        name: "节点名称",
        children: [],
      }
    ]
  }

记录
  如何重新渲染图表？
    resize() 图表会重置
    setOption() 图表会重置

  如何拿到 zrender 对应的模型实例
    Storage.ts（数据模型）
    PainterBase.ts（视图绘制）
    Handler.ts（交互控制）

    myChart.getZr().storage._displayList.filter(d => d.constructor.toString().substr(9, 5) === 'TSpan')
    myChart.getZr().storage._displayList.find(d => d?.style?.text?.indexOf('跨境外币汇率查询') === 0)

    myChart.getZr().storage._roots[2]
  
  ECharts.prototype.setOption
    Tree.createTree // dataNode => treeNode, 对这里进行改造，使得 treeNode 也带上自定义信息
    updateMethods.update.call(this, null, updateParams); 
      render(this, ecModel, api, payload, updateParams);
        renderSeries(ecIns, ecModel, api, payload, updateParams);
          renderTask.perform(scheduler.getPerformArgs(renderTask))
            TreemapView.prototype.render
              this._doRender(containerGroup, seriesModel, reRoot); // 这个过程中生成了 storage


    this._zr.flush() // 此时 storage 已生成
      this.painter.refresh()
        var list = this.storage.getDisplayList(true)
        this._paintList(list, prevList, paintAll, this._redrawId)


  echarts
    SeriesModel
    chartView
    visual
    layout
    action
    

  zrender 的三层架构 https://zhuanlan.zhihu.com/p/372895633
    模型层 Storage: 类似虚拟DOM，是图形实例的树状结构，控制图形实例的增删改查
    视图层 Painter: 管理canvas的生命周期，负责视图渲染、更新控制、绘图
    控制层 Handler: 控制事件交互，封装模拟DOM事件
    辅助模块: 
      animation
      tool: 颜色转换、路径转换、矩阵运算等方法
      graphic: 图形对象基类
      contain: 包含关系相关算法，比如坐标点是否在图形内

  echarts Series 中的 data，如何转化成 Storage？


  treemapZoomToNode 被调用时，发生了什么？




  节点的分层加载功能
    √ 隐藏下层节点
    