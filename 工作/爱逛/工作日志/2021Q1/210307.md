上周工作回顾 & 遗留
  - vanx 分享
    - watcher 原理
    √ Dep.target 的设置时机 - 创建 Watcher 实例的时候
    √ 为什么在 mutation 每次修改 state 都会触发一次 watch
    √ 不参与渲染的数据, 放在 computed 比放 mapData, 拥有更好的渲染性能 - mapData 会调用 setData
    - 参与渲染的数据, 使用 mapState 或 mapGetters 计算, 比 mapData 整个对象, 拥有更好的渲染性能
  - vue-Router 源码
  - 天网工具迭代
  - 天网各项目报错的可视化界面

  - 日志上报方案调研
    错误捕获
    批量上报

本周工作安排
  √ 商家后台 达人认证 -待发布
    √ 级联功能优化
  - 爱逛精选合并 
    prd: https://doc.qima-inc.com/pages/viewpage.action?pageId=312091646
    ui: https://lanhuapp.com/url/nwcTx-2l0I3
    进度: https://doc.qima-inc.com/pages/viewpage.action?pageId=312761896
    - 小程序搜索模块, 按类搜索
    - 小程序首页搜索热词, 运营后台热词管理

  - sku多网点调整 - 待发布
    √ 网店有货时, 也给出提示文案, 5秒后自动消失：该商品有多网点销售, 请选择最近网点下单

  - 运营后台 动态路由

本周完成情况
  周一 / 周二 / 周三 
    
  周四
    - 爱逛精选合并
      - 小程序首页搜索热词, 运营后台热词管理
        第一位新增【逛逛首页推荐】，用于控制新版逛逛首页的资源位，逻辑同【直播首页推荐】
        √ 原有【首页推荐】改名【直播首页推荐】
        √ 原有【分类推荐】改名【搜索推荐】
        √ 点击配置直接配置对应的热词，不再中转下
        √ 模块新增，搜索框热词，用户控制新版逛逛首页的搜索框热词

      - 小程序搜索模块, 按类搜索
        
  周五

  周六
    
本周复盘总结
  进度: 未延期 ｜ 延期 N 天
  质量: 出现线上问题 N 次, 产品验收发现问题 N 个
  需要保持:
  需要提高:
  心得:

临时任务 & 下周计划
           
## 知识点记录
  - 组件懒加载
    - 为什么要做组件懒加载
      三级页面的持续增加，路由配置写法过于臃肿，影响可读性，且单文件过大容易影响首屏加载
    - 怎么做
      const Component = react.lazy(() => import('./recommend-home'))
      return <Component>
    - 收益
      1. 不需要提前加载所有用到的组件，首屏渲染加快
      2. 写法上不需要为url指定渲染的组件，只需要给出组件的文件路径，可以单独抽离成一个配置文件，可读性更好
    - webpack 对 import() 的代码分割 https://mp.weixin.qq.com/s/yGjk4WeumU560d_IJYL92A
      import() 是动态加载模块的规范，返回 promise
      webpack 打包时解析到 import() 会进行代码分割
    - react.lazy 原理 https://www.cnblogs.com/forcheng/p/13132582.html

    - 遇到问题: 
      1. 路由给定常量可以加载，变量加载失败
          import('./recommend-home') √
          import(path)  √
        - 解决方案: 在 path 前面加 父级路径, 即 import(`../home-page-manage/${path}`)
        - 原因: 
          https://segmentfault.com/a/1190000015648036
      
      2. css 冲突警告
        动态加载的情况下，使用 mini-css-extract-plugin 的 loader 时，多个js引用同一 css 出现 警告

      3. 组件动态加载后 componentDidMount 执行多次问题
        正常 componentDidMount 钩子应该只在 render 后执行一次
        推荐组件 Home 里，打开弹窗时会再次执行 Home 的 componentDidMount
        原因分析: 
          1. 执行了两次说明 Home 组件可能经历了 卸载-重新 加载，这一点通过 componentWillUnmount 得到了证实
          2. 打开弹窗时，有调用 setState 触发重新渲染
          3. 渲染时，会进行 diff 判断组件能否复用
          4. lazy 加载进来的组件，在 diff 时每次都被认为是不同类型的 组件，因此直接进行了卸载
        问题定位: 
          setState 触发渲染时，lazy 加载进来的组件没有复用，每次都是重新加载
        解决方案:
          缓存 lazy 加载进来的组件，在渲染组件前判断 路由，决定 复用 或者 重新用 lazy 加载

  - webpack 优化
    - 指标 speed-measure-webpack-plugin
    对性能开销大的 loader 使用 cache-loader，将会生成 json 文件缓存转换结果
    对耗时的 loader 使用 thread-loader，在独立线程进行转换 https://www.webpackjs.com/loaders/thread-loader/

    thread-loader babel-loader babel-loader ts-loader
    thread-loader cacheLoader babel-loader
    css-hot-loader mini-css-extract-plugin thread-loader cssLoader cacheLoader postcssLoader sassLoader
    css-hot-loader mini-css-extract-plugin cssLoader cacheLoader postcssLoader

  - webpack 对 import 静态引入的资源，如果没有使用，也不会打包进来

  PureComponent

本周工作记录

  sku 面板 多网点 选择流程
    点击网店选择 -> 跳转到网店选择页
    sku面板选择网店 
      -> saveStoreAndJumpBack 
        -> app.setOfflineId 存入网店信息
          -> 跳回之前页面 
            -> this.$broadcast('app:store-changed')

    sku面板组件接收 app:store-changed
      -> requestGoodsSkuByAlias 获取商品详情
        -> _updateComponentData 更新数据


备忘录

