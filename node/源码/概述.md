## node 的启动流程 https://zhuanlan.zhihu.com/p/92305600，https://segmentfault.com/a/1190000014147207
  - node_main.cc: main() -> node::Start()
  - node.cc: Start() -> main_instance.Run()
  - node_main_instance.cc: Run()
    CreateMainEnvironment()
      ...
      HandleScope handle_scope(isolate_); // 跟v8相关 todo
      ... 
      node.cc: RunBootstrapping()
        BootstrapInternalLoaders()
          ExecuteBootstrapper()
            ... // todo 这里的调用时机未确认
            node_native_module.cc: LoadJavaScriptSource()
            ...
            node_native_module_env: lookupAndCompile()
              node_native_module.cc: lookupAndCompile()
                ```
                  // 首次编译的是 internal/bootstrap/loaders.js 
                  // 该文件导出 
                    const loaderExports = {
                      internalBinding,
                      NativeModule,
                      require: nativeModuleRequire
                    }
                  // 之后编译 internal/bootstrap/node.js
                  // 该文件内设置 process、global、Buffer 等全局对象
                ```
        ...
        DoneBootstrapping()

    environment.cc: LoadEnvironment()
      env.cc: InitializeLibuv()
      node.cc: StartExecution()

## libuv 事件循环

## v8引擎

## 

## js2c.py 调试 
1. 环境 python3+
2. 设置断点
  方法一: pdb: https://www.jianshu.com/p/fb5f791fcb18
    import pdb
    pdb.set_trace()
  方法二: vscode
    {
      "name": "Python: 当前文件",
      "type": "python",
      "request": "launch",
      "program": "/Users/chenyike/Desktop/work/node-src/node/tools/js2c.py",
      "console": "integratedTerminal"
    }

3. 开始调试 python /Users/.../node/tools/js2c.py
4. 设置源文件 options.sources = ['tools/js2c.py', 'lib/console.js', 'config.gypi']
5. 步入到 AddModule
  - 读取源码: code = ReadFile(filename) // 拿到文件内容，字符串形式的js代码
  - 转ASCII码: 执行 GetDefinition(var, code) // var 是标识符的意思，格式为 文件名_raw
    code_points = [ord(c) for c in source] 
      // 将js代码转为 ASCII码，如前四个字节为 '47, 47, 32, 67'，对应 '// C'
      https://tool.oschina.net/commons?type=4
    elements_s = ['%3s' % x for x in code_points]
      // 格式化代码，如 '47' 转为  ' 47'
    slices = [elements_s[i:i + step] for i in range(0, len(elements_s), step)]
      // 将 ASCII码 按 30字节一组 分为 二维数组
    lines = [','.join(s) for s in slices]
      // 将 二维数组的每一行单独组成 字符串，重新得到 一维数组
    array_content = ',\n'.join(lines)
      //翻译过来就是 lines.join(',\n')
  - 模版拼接:
    TEMPLATE.format(definitions, initializers, config_size)
    其中 initializers 理解为标识符集合，形如 'source_.emplace("console", UnionBytes{console_raw, 1202});'
    definitions 为之前得到的 ASCII码形态的JS代码 的数组
    最终得到的 C++片段形如
    ```
      #include "env-inl.h"
      #include "node_native_module.h"
      #include "node_internals.h"

      namespace node {{
        namespace native_module {{
          static const uint8_t console_raw[] = {{
            \n 47, 47, 32, 67,111,112 ... // lib/console.js 转出来的 ASCII码
          }};

          void NativeModuleLoader::LoadJavaScriptSource() {{
            source_.emplace("console", UnionBytes{console_raw, 1202});
          }}

          UnionBytes NativeModuleLoader::GetConfig() {{
            return UnionBytes(config_raw, {2});  // config.gypi
          }}
        }}
      }}
    ```
  - 写入文件系统 <(SHARED_INTERMEDIATE_DIR)/node_javascript.cc
    SHARED_INTERMEDIATE_DIR 根据开发/生产环境，取值为 /node/out/(Debug | Release)/obj/gen