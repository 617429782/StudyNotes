
## 响应式设计的实现  
  响应式设计的本质是 观察者模式的自动化
  观察者模式的基础实现是 被观察者(主题) 维护 观察者的列表, 并在合适的时机通知 所有观察者

  ```
  // 被观察者类 伪代码
  class Subject {
  	watchers: []       // 观察该 Subject 的所有 Watcher 实例
  	addOb() {}
  	removeOb() {}
  	notify() {}        // 通知所有的 Watcher 实例, 调用 update 方法
  }

  // 观察者类 伪代码
  class Watcher {
  	update() {}
  }
  ```

  在 Vue@2.x 和 Vanx 中, 被观察者 和 观察者 分别对应 Dep 和 Watcher; 在 Wex 中, 对应 Subject 和 Watcher  
  自动化 主要是三个步骤, 即 将一个对象转为响应式(调用 defineReactive)时, 自动为其

  - 创建被观察者实例
  - 添加 Watcher(依赖收集)
  - 通知 Watcher

  ```
  function defineReactive(target, key, value) {
  	const dep = new Dep();  // 创建 Subject 实例 的自动化
  	Object.defineProperty(target, key, {
  		get() {
  			dep.depend();       // 添加 Watcher 的自动化
  			return value;
  		},
  		set(newVal) {
  			value = newVal;
  			dep.notify();       // 通知 Watcher 的自动化
  		}
  	})
  }
  ```

## 在 Vue@2.x、 响应式设计都是基于 Object.defineProperty  
  Observer 的主要作用, 就是为 Object.defineProperty 提供 属性描述符 (主要是 get 和 set)  
  上文中, dep.depend 的作用是 为 Dep 实例添加 Watcher, 并将 Dep 自身添加到 Watcher 下
  那么又有一个问题, target.get 在被读取时就会调用, 但并不是每次读取都要 为 Dep 添加 Watcher, 如何区分？

  ```
  class Dep {
  	depend() {
  		Dep.target && Dep.target.addDep(this)		// Dep.target 在什么时候存在？
  	}
  }

  class Watcher {
  	constructor (expOrFn, cb, options) {
  		this.getter = parsePath(expOrFn);
  		this.cb = cb
  		this.value = this.get()
  	}
  	addDep(dep) {
  		dep.addOb(this)
  	}
  	get() {
  		Dep.target = this;
  		// 通过调用 getter 来触发 target 的 get, 完成 依赖搜集
  		let value = this.getter.call(null)
  		Dep.target = null;
  		return value;
  	}
  }

  const o = { age: 10 }

  new Watcher(() => {
  	return o.age
  }, (val, old) => {
  	console.log(val, old)
  })

  new Watcher('o.age', (val, old) => {
  	console.log(val, old)
  })
  ```

  可以看出, 调用 Watcher.get 期间 Dep.target 会被设置成 Watcher 本身, 通过调用 Watcher.getter 来触发 target.get 来完成依赖收集

## 小结
  1.  响应式设计的基础是 观察者模式的自动化, 核心在于 Object.defineProperty 的 get/set
  2.  每个被转成响应式的 对象, 都有属于自己的 Dep 实例, 用于管理观察者 Watchers
  3.  并不是每次触发 get 都会进行依赖收集, 只有特定的时机 如 new Watcher、Watcher.update 才需要进行收集

## 轮子
  ```
  class Dep {
    constructor() {
      this.watchers = new Set();
    }
    addOb(sub) {
      this.watchers.add(sub);
    }
    removeOb(sub) {
      this.watchers.delete(sub)
    }
    depend() {
      // Dep.target 必须是 watcher 实例
      Dep.target && Dep.target.addDep(this)
    }
    notify() {
      this.watchers.forEach(watcher => {
        typeof watcher?.update === 'function' && watcher.update()
      })
    }
  }

  class Watcher {
    constructor(getter, cb) {
      this.deps = new Set();
      // 在vue中, getter支持 函数 和 属性链取值 两种方式, 属性链也会被转成函数的形式
      this.getter = getter;
      this.cb = cb;
      this.get()
    }
    addDep(dep) {
      dep.addOb(this)
    }
    clearDep() {   // 在vue中, watcher通常不是一对一地解除观察, 而是在销毁时统一清除
      for (const dep of this.deps) {
        this.deps.delete(dep);
        dep.removeOb(this);
      }
    }
    get() {
      Dep.target = this;
      // 通过调用 getter 来触发 target 的 get, 完成 依赖搜集
      let value = this.getter.call(null)   // vue 中, getter 的上下文是 组件
      Dep.target = null;
      return value;
    }
    update() {
      const value = this.get()
      const oldValue = this.value
      this.value = value
      typeof this?.cb === 'function' && this.cb.call(null, value, oldValue) // vue 中, cb 的上下文是 组件
    }
  }

  function defineReactive(target, key) {
    let _value = target[key];
    const dep = new Dep();  // 创建Subject实例 的自动化
    Object.defineProperty(target, key, {
      get() {
        dep.depend();       // 添加Observer 的自动化
        return _value;
      },
      set(value) {
        _value = value;
        dep.notify();       // 通知Observer 的自动化
      }
    })
  }

  const o = { age: 1 }
  defineReactive(o, 'age')
  new Watcher(() => {     // vue 中创建 Watcher 实例的时机有, mountComponent、$watch、initComputed
    return o.age
  }, (val, old) => {
    console.log(val, old)
  })
  o.age = 123
```
