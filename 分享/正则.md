1. 开场 (主题、内容概述、目的)
  今天我们来聊聊正则
  我们都知道正则的本质是字符串匹配, 但是他的语法比较难记, 往往是现查现用, 效率较低
  所以我们今天会通过一些示例和场景的类比, 帮助大家加深对正则匹配机制的理解
  争取让大家在三十分钟内基本掌握正则

  聊一聊为什么要学习正则

  JS处理字符串的能力这么强大, 为什么要学习正则 --为了读和写
    编码效率、执行效率 (通过两段代码来对比)
    为了阅读代码 (通过框架源码、项目中的一段正则来简述场景)

重点一: 匹配 正则的本质是匹配, 要么是匹配字符, 要么匹配位置

2. 字符匹配: [] 确立规则, {} 决定数量
  规则 /[p]/: 是对单个字符的最低要求, 满足一项就符合
    场景: 第一次相亲, 对姑娘有什么要求? 
      /[白皮肤大眼睛长头发]/ 比较拘谨, 满足一项就可以
    示例: 'abcde'.replace(/[abc]/, '_')  =>  '_bcde'
    连字符 - 和 排除符 ^
      /[abcde]/ 等同于 /[a-e]/ 同理有 A-Z0-9a-z
      /[^花心的]/ 'abcde'.replace(/[^abc]/, '_')  =>  'abc_e'
    内置字符匹配规则 小写表命中, 大写表排除
      \w \W: word (字母、数字、下划线) 
      \s \S: space (空白符 空格、换行\n、换页\f、回车\r、水平/垂直制表符t/v)
      \d \D: digit (数字)
      . 通配符 几乎所有字符, \n \r 除外
   
  数量 /[p]{n, m}/: 规则后面紧跟数量, 表示满足规则的字符 需要达到一定数量, 形成字符串
    场景: 第二次相亲, 为了提高效率, 让红娘一次多找几个备选
      /[白皮肤大眼睛长头发]{3}/ 一次找了三个
    示例: 
      /[a-z]{3}/.test('ab') => false
      /[a-z]{3}/.test('abc') => true
    语法: {n,m} {m} {m,}
    内置量词简写
      ? {0,1} 有或者没有
      + {1,}  至少有一个
      * {0,}  随便多少个

  多选分支 /[p1]{m}|[p2]{m}/
    场景: 第三次相亲, 觉得效率还是不够高, 找了两个红娘, 顺带换换口味
      /[白皮肤大眼睛长头发]{3}|[高学历会做饭有爱心]{3}/
    示例:
      '1234abcde'.replace(/\d{3}|[abcde]{3}/g, '_')  =>  '_4_de'

  贪婪/惰性匹配: 量词后面加问号: 够了吗
    场景
      /\d{1,3}/   我的饭量是1勺到3勺, 阿姨不问, 一勺一勺地加, 我看加到3勺了, 急忙说 够了够了
      /\d{1,3}?/  阿姨打完1勺问, 够了吗, 那就矜持一下, 1勺够了

    示例
      'abc123456789efg'.replace(/\d{2,5}/g, '@')    =>   'abc@@efg'
      'abc123456789efg'.replace(/\d{2,5}?/g, '@')   =>   'abc@@@@9efg'

3. 位置匹配: 找字符间的空隙, 包括开头和结尾
    位置: 'hello' 一个有6个可用的位置
    位置可以理解为空字符串, 一个位置可以被使用多次, 但只生效一次
      /^^^hello$$$/.test('hello')  =>  true
      'hello'.replace(/^^^/, '^')  =>  '^hello'

    内置位置匹配规则
      ^ 开头位置 '2000'.replace(/^/, '¥') => '¥2000'
      $ 结尾位置 
      \b 单词间隙, 理解为 \w 与 \W 之间的位置, 也包括 \w 和 ^以及$ 之间的位置, \B 正好相反
        'hello world'.replace(/\b/g, '^')  =>  '^hello^ ^world^'
        'hello world'.replace(/\B/g, '^')  =>  'h^e^l^l^o w^o^r^l^d'

    (?=p) 正向肯定: 某个位置 后面 满足 p 'abc123'.replace(/(?=\d)/, '_') => 'abc_123'
    (?!p) 正向否定: 某个位置 后面 不满足 p 'abc123'.replace(/(?!\d)/, '_') => '_abc123'

    后来加的内置规则, 可能有兼容性问题
    (?<=p) 反向肯定: 某个位置 前面 满足 p 'abc123'.replace(/(?<=\d)/, '_') => 'abc1_23'
    (?<!p) 反向否定: 某个位置 前面 不满足 p 'abc123'.replace(/(?<!\d)/, '_') => '_abc123'

重点二: 分组 分组的功能是 多字符匹配 + 引用

4. 分组
  分组和分支: 分组内的 | 形成 或 分支, 多个分组之间构成 且 关系
    多字符匹配
      规则 是对单个字符的匹配, 如果需要匹配多个字符, 需要用到分组 
      场景: /(颜值高会做饭)/ 要求变高了, 不光要颜值高, 还要会做饭了
      示例: /(ab){2,}/.test('ababc') => true
    分组内的或分支
      示例: 去掉url的协议部分 'http://meituan.com' => 'meituan.com'
        'http://meituan.com'.replace(/http|https:\/\//, '')  =>  '://meituan.com'
        'http://meituan.com'.replace(/(http|https):\/\//, '')  =>  'meituan.com'
    <!-- 分组间的且关系
      '123^abc'.replace(/(\w)/g, '') => '^'
      '123^abc'.replace(/(\w)(\d)/g, '') => '3^abc' -->

  引用: 捕获分组匹配到的结果, 在之后使用
    在正则完成后引用
      示例: '2021-11-08' => '11-08-2021'
        '2021-11-08'.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2-$3-$1')
      取的是 RegExp.$1 ~ RegExp.$9, 类似于字符串模版
    在正则的后续部分引用
      示例: 日期格式验证 '2021-11-08 | 2021/11/08' 
        /\d{4}(\/|-)\d{2}(\/|-)\d{2}/.test('2021-11-08')  =>  true
        /\d{4}(\/|-)\d{2}(\/|-)\d{2}/.test('2021-11/08')  =>  true
      可以使用 \1~\n 拿到前半部正则分组匹配到的结果
        /\d{4}(\/|-)\d{2}\1\d{2}/.test('2021-11-08')  =>  true
        /\d{4}(\/|-)\d{2}\1\d{2}/.test('2021-11/08')  =>  false
    四种边界情况
      括号嵌套时怎么确定引用顺序 -> 以左括号的出现时机排序
      \10 代表第10个引用, 还是第1个引用后面跟着0 -> 第10个引用
      引用不存在的分组怎么办 -> 转为匹配 '\1' 这个字符本身
      分组后面有量词时, 怎么捕获 -> 捕获最后一次匹配
        /(\d)+ \1/.test('12345 1') => false
        /(\d)+ \1/.test('12345 5') => true
  
  非捕获匹配 (?:)
    可以指定分组中的匹配结果不被捕获
    '1234'.replace(/(\d+)/, '¥$1') => '¥1234'
    '1234'.replace(/(?:\d+)/, '¥$1') => '¥$1'
  
随堂测验: 数字的千位分隔符表示 '123456789' => '123,456,789'
  找出后面跟着三位数字的位置 '123456789'.replace(/(?=\d{3})/g, ',') => ',1,2,3,4,5,6,789'
  先找出最后一个逗号的位置 '123456789'.replace(/(?=\d{3}$)/g, ',') => '123456,789'
  根据步骤2, 找出其他逗号的位置 '123456789'.replace(/(?=(\d{3})+$)/g, ',') => ',123,456,789'
  最后排除掉开头的逗号 '123456789'.replace(/(?!^)(?=(\d{3})+$)/g, ',') => '123,456,789'

5. 结尾
  今天我们从 字符匹配、位置匹配、分组 三个方面梳理了正则的匹配机制, 希望对大家有所帮助
  推荐一个正则可视化网址 https://jex.im/regulex/#!flags=&re=%5Cd%7C%5Cw 
  以及 正则表达式迷你书, 本文中很多思想都是来自这本书的上半篇
  感谢聆听