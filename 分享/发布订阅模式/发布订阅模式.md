开场
  今天我们来聊聊设计模式中的发布订阅模式，很多人可能会说啊，这个简单，发布订阅谁不会写。
  确实，发布订阅是前端几乎每天都在接触的一种模式，为什么这么说呢，因为JS是事件驱动的，而事件就是发布订阅模式最经典的实现。
  今天我们要聊的，是发布订阅模式在主流框架中的应用，以及如何在我们的日常开发中落地

part1 观察者 vs 发布订阅模式
  为什么要有观察者模式呢？我们举个例子
  大家都知道罗永浩老师对吧，他之前一段时间欠了很多人的钱，大家追着他天天催是吧。罗老师一想，这样不是办法，于是他就让大家拿着借条在他那登记一下收款码，他一拿到钱就会挨个还。
  观察者模式定义: 一个对象维护着另外一系列对象，并且在状态改变时通知他们。
  观察者模式的简单实现
  ```
    // 被观察者
    class Subject {
      observers = [] // 债主列表
      add () {}      // 再找人借点，应应急
      remove () {}   // 还完一个，互删退圈
      notify () {}   // 挨个还钱
    }
    // 观察者
    class Observer {
      update() {}    // 收款
    }
  ```
  从上述的例子我们看到，罗老师通过观察者模式将自己和债主的关系由强耦合变成了松散耦合，大家不用天天堵着他家大门了，只需要实现一个收款的API就行，这对罗老师来说也方便了是吧，他不用关心债主是现金收款还是微信转账，可以面向接口编程。

  但是时间一久，他就发现啊这个债主实在是太多了，占用了他很多精力去管理，他为了还上钱，还得带货、接广告，想办法搞钱对吧，所以他雇了个秘书帮他登记，不管是要债的、谈合作的还是其他的，都分门别类地记在秘书那，他自己专注于做事情，等到有空了，他就找秘书要待办的清单。
  发布订阅模式定义: 引入第三方作为事件中心，发布者和订阅者的行为需要借助第三方完成。
  发布订阅模式的简单实现
  ```
    // 秘书的记事本
    class Event {
      events = {}   // 日程、待办
      on() {}       // 每周五晚上，预定搞一场直播
      off() {}      // 上次那个供应商黄了，直播取消了
      once() {}     // 下周四临时有事情，订一张飞机票
      emit() {}     // 周五到了，该开工了
    }
  ```
  从上述的例子我们看到，罗老师雇了一个秘书作为第三方，将自己的精力解放出来，他不再需要关注具体的债主和合作方是谁，需要做什么，他只需要到时间去做事就行。所以这时候他们之间的关系就从之前的松耦合变成了无耦合。

  那么，他们观察者模式和发布订阅模式之间的异同也就出来了，观察者模式是松耦合的，发布者拥有订阅者的【管理权】，可以方便添加/移除订阅者，并且可以感知订阅者的运行状态，比如其中一个订阅者的回调执行失败了，他可以被发布者察觉和处理，而发布订阅模式是无耦合的，他需要第三方来管理消息队列，发布者和订阅者相互之间不需要联系。

  