网络请求 发起的 渲染事件流
交互行为 发起的 渲染事件流


插件机制的设计理念
  1. 明确程序执行的工作流，可能是线性的、循环的、点状的
  2. 确定工作流中的哪些环节是固定不可变的，哪些环节可以对外暴露并被修改的，可变的部分通常会形成一系列 hooks，作为暴露给插件的一部分
  3. 确定暴露给外部的内容，通常是插件被执行时可以拿到的参数，这决定了插件的能力边界，需要权衡插件的自由度给主程序带来的不可控性
  4. 插件机制的基本逻辑是 注册 + 执行，由一个【管理器】收集、管理、执行【插件期待被执行的方法】




webpack 的插件机制
  注册方式: 配置注册
    1. 在 options 中声明将要使用的 plugins
    2. plugin 是一个含有 apply 方法的实例对象
  执行时机: 延时执行
    compiler 对象开始工作前会读取 plugin，并依次执行其 apply 方法
  能力边界
    1. plugin.apply 执行时，可以拿到 compiler 对象，并在其上的 hooks 注册钩子实现能力的扩展
    2. webpack 的插件机制是面向过程的扩展，将打包流程划分为 初始化、编辑、组织、输出 等环节，并在各个环节以及细节的执行前后，向 hooks 暴露中间结果并允许修改

vue 的插件机制
  注册方式: 显式注册
    1. 在 new Vue() 执行前，调用 Vue.use() 进行插件的注册
    2. Vue.use(plugin, ...options) 接受【一个函数】或【一个带 install 函数的对象】
  执行时机: 即时执行
    注册即执行，Vue.use() 调用后即完成了插件的注册和执行, use 会调用插件的 install 方法: plugin.install(Vue, ...options)
  能力边界
    执行时，可以拿到 Vue 的构造函数，并调用其静态方法如：Vue.component

阿里低代码引擎的插件机制
  注册方式: 显示注册
    1. 【搭建平台】通过调用【engine】对外暴露的【插件管理器】中的【register】方法，可以在不同的【场景模版】完成各自所需的插件注册
    2. LowCodePluginManager.register(fn, options, registerOptions) 接受一个函数并执行，其返回值为一个拥有 init 方法的对象
  执行时机: 延时执行 + 即时执行
    【engine.init】执行时，会在渲染任务开始前，统一执行已注册 plugin.init 方法
    若注册插件时，在配置项中给了 autoInit 参数，则会在注册时即时执行
  能力边界
    1. plugin.init 执行时，可以访问引擎暴露给插件的一些全局变量、实例，如 skeleton、project、setters、plugins、material 等（ILowCodePluginContext）
    2. plugin 可以直接调用这些实例的 api，比如 skeleton.add() 完成扩展
    3. 引擎的扩展思路主要是UI层面的新增，由【平台开发者】自行考虑 实例API 的调用时机，也提供了 hooks 机制，在特定时机增加回调
    4. 插件管理器提供了 plugin 的管理功能，比如重复注册时的覆盖、注销、禁用等

天河编辑器引擎
  注册方式: 显示注册
    1. 在 new Vue() 执行前, 调用 pluginManager.register 完成插件的注册
    2. pluginManager.register 接受一个含有 main 方法的实例对象
  执行时机: 延时执行
    引擎会在 渲染任务开始前，统一执行已注册过的 plugin.main 方法，并向其传递 LowCodeContext 实例对象
  能力边界
    天河编辑器的扩展方式结合了 webpack 和 阿里低代码引擎的特点，在 LowCodeContext 实例对象中即包含了各个全局模块的实例对象，允许在 plugin.main 中直接调用其API，同时也基于【网络请求、交互行为】发起的渲染事件流，向【平台开发者】提供 hooks，使其拥有影响、改变引擎默认逻辑的能力