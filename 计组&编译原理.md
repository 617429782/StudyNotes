## 机器语言、汇编语言、高级语言
  机器语言: 二进制码, 可以被CPU直接执行
  汇编语言: 特定二进制码的映射, 例如 R: 11111010, 属于 低级语言, 需要转译成二进制后被CPU执行
  字节码: 与汇编类似, 都属于 高级语言 和 机器码 之间的过渡码, 但需要特定的翻译器, 比如 java字节码 需要 JVM, 其抹平了不同平台的差异
  高级语言: 贴近人类语言, 跨平台, 需要编译后才能执行

## CPU 的组成 
  运算器
  控制器
  寄存器
    通用寄存器: 暂存数据, 也可参与逻辑运算, 用于暂存运算结果
    PC寄存器(也叫程序计数器): 存放、更新指令地址
    指令寄存器: 存放当前正在执行的指令
    数据寄存器: 
  内部总线: 用于上述CPU内部各个器件之间的联系
  外部总线: 用于 CPU 与主板上其他器件的联系

## CPU执行机器语言的流程 https://mp.weixin.qq.com/s/IJ-yH-Ze93zr5qgmjKwRrQ
  1. 将 二进制程序 装进 内存
  2. 将 二进制程序 中的 第一条指令地址 写入 PC寄存器(也叫程序计数器)
  3. CPU 根据 PC寄存器 中的指令地址, 从内存中取出指令, 存于 指令寄存器
  4. PC寄存器 更新 下一条指令地址 (地址+1 或者 转移指针到下一条指令地址)
  5. CPU 分析当前指令, 根据指令类型完成操作, 指令 由 操作码 + 地址码 组成
    加载指令
    存储指令
    更新指令
  6. 指令执行完毕, 进入下一个CPU时钟周期

## JS引擎
  高级语言分为
    编译型语言: 一次编译, 多次执行, 启动慢但执行快, 如 c、c++
    解释型语言: 通过解释器边解释边执行, 启动快但执行慢, 如 Java, 通过虚拟机(JVM)进行即时编译(JIT)
  JS是动态类型语言, 因此需要一个能快速 解析并执行js脚本的程序, 即js引擎, V8引擎本质是一段C++程序

  // 提问: 前文说到, 二进制脚本由CPU执行, 为什么V8可以执行js脚本？
  // todo: (JS字节码是如何执行的) 引擎的本质就是一段程序, 其被编译成二进制后 就在被CPU执行, 其实现了一个基于寄存器的解释器

## V8引擎的组成
  - 编译器: 将js代码编译成 字节码 或 二进制码(热点代码)
    - 基线编译器: 将 AST 转为 字节码
    - 优化编译器: 将 字节码 转为 机器码, 热点代码保存为机器码, 省去字节码的过渡流程

  - 解释器: 解释执行字节码


## V8编译流程 (源码 -> AST -> 字节码 -> 机器码)
  1. 初始化基础环境
    V8执行js代码需要 宿主环境, 可以是 浏览器 或 node
    当打开一个浏览器进程时, 就为 V8 提供了一个 运行时环境
    // todo 这里需要确认 事件循环 与 v8 中 libuv 的关系
    运行时环境为V8提供了 堆空间、栈空间、全局执行上下文、事件循环系统、宿主对象、宿主API

  2. 解析源码生成 AST 和 作用域
  3. 根据 AST 和 作用域 生成 字节码
  4. 解释执行 字节码, 监听 热点代码(多次执行过的)
    (CPU 执行二进制机器代码类似 内存 + 三大寄存器)
    使用内存中的一块区域来存放字节码
    通用寄存器 用来存放一些中间数据
    PC寄存器 用来指向下一条要执行的字节码
    栈顶寄存器 用来指向当前的栈顶的位置

  5. 即时编译
    执行字节码的过程中, 如果发现 热点代码, 那么编译器会将这段 字节码 编译为 机器码, 省去反复编译的过程

## V8的优化策略
  1. 字节码: 
    直接将js编译成机器码需要 较长的编译时间 并 占用较多内存
    用字节码过渡, 虽然牺牲一点执行速度, 但提高了编译速度、减少了内存消耗, 并减少了V8跨平台的成本
  2. 延迟解析
    解析器在解析时, 遇到函数声明则跳过函数内部代码, 不为其生成ast和字节码
    这样做的好处是减少首次编译时间以及不必要的内存占用
  3. 隐藏类
    V8为每个JS对象创建了一个隐藏对象, 用于记录对象属性名和属性值对应的偏移量, 这在后续的访问过程中可以缩短内存寻址的时间
  4. 快慢属性

  5. 内联缓存





- 1. 代码由CPU执行, CPU无法执行 高级语言 的语法 (if...else), 仅能执行 二进制指令 (1000010010101001)
- 2. 汇编语言: 二进制指令 的 映射助记符, 例如 R: 11111010, 属于 低级语言, 也需要编译成二进制后被CPU执行
- 3. 四元式: (操作符, 参数1, 参数2, 临时存储对象)
  ```
    X = a*b + c/d
    (1) (*, a, b, T1)
    (2) (/, c, d, T2)
    (3) (+, T1, T2, T3)
    (4) (=, T3, -, X)
  ```
- 4. 三地址代码: 四元式的另一种表达
  ```
    X = a*b + c/d
    (1) T1 = a*b
    (2) T2 = c/d
    (3) T3 = T1 + T2 
    (4) X = T3
  ```
- 5. CPU 与内存间有三条总线: 地址、数据、控制
- 6. CPU 工作流程分为: 取指令、指令译码、执行指令、访存取数、结果写回 https://zhidao.baidu.com/question/124425422.html
  取指令: 将一条指令从主存中取到指令寄存器的过程
  指令译码: 
  执行指令: 
  访存取数: 
  结果写回: 

## 程序的执行过程
  - 常规编译型语言(java)的执行过程 
    编译: 词法分析 -> 语法分析 -> 语义检查 -> 代码优化 -> 字节生成(输出给JVM, 由其转为二进制指令, 以抹平操作系统的解释器差异)
    链接: 将多个目标文件合并成一个可执行文件 (静态链接)
    执行: 操作系统将可执行代码(二进制指令)加载到内存中执行

  - 解释型语言(JS)的执行过程
    词法分析 -> 语法分析 -> 预编译(变量/函数声明) -> 逐行解释(转二进制指令)执行
    参与JS编译执行的关键角色: 
      引擎: 负责整个JS程序的编译及执行过程
      编译器: 负责语法分析, 代码生成等
      作用域: 负责变量存储, 确定其访问规则

## 计算机中的计量单位 https://tech.sina.com.cn/roll/2020-07-09/doc-iirczymm1498194.shtml
  - 位 (bit): 最小的单位, 二进制中的 0 或 1
  - 字节 (Byte / B): 1字节 等于 8位 
  - KB / MB / GB: 1KB = 1024B, 依次类推
  - 字符: 字符大小根据编码方式而定, 一个 ASCII码 或英文字母 为 1字节,  一个UTF8编码的中文为 3字节

## 地址空间
  - 磁盘: 扇区 / 磁盘块 / 页
    扇区: 物理概念
      硬盘的读取以扇区为基本单位, 通常为 512字节 (理解为光盘上的一个弧形片段)
    磁盘块: 逻辑概念
      操作系统不直接操作扇区, 而是与扇区的集合 磁盘块 交互
      磁盘块是文件读写系统的最小单位, 一个磁盘块可以包含 2^n 个扇区
      一个磁盘块只能存放一个文件, 因此文件占用空间一定是磁盘块的整数倍, 如此便可能出现 文件实际大小小于磁盘占用空间
      (文件的存储方式类似链表)
  - 内存: 物理内存 / 虚拟内存
    页: 内存的最小存储单位, 大小通常为 2^n 个磁盘块
    内存可以类比成一块连续的数组, 数组的每个字节都有一个唯一的地址
    物理内存: 例如 1GB (2^30) 的物理内存, 其物理地址为 [0, 1, 2, ..., 2^30-1]
    虚拟内存: 64位 的电脑, 其每个进程都认为自己有 [0, 1, 2, ..., 2^64-1] 的地址空间 (多出来的部分是磁盘配合完成的)
    系统将 物理内存 和 虚拟内存 划分位等长的 页, 为每个进程维护 页表 用于 虚拟-物理 内存映射
    系统访问虚拟内存时, 首先根据页表查询物理地址, 若存在直接返回, 不存在 更新页表, 将暂时不用的页替换成本次所需的内容

  