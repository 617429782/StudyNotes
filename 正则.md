匹配模式 {} / []
  (1) {} 用于指定匹配的长度
    如 /ab{2,5}c/ 指匹配 a开头,c结尾, 中间间隔 2到5个字符b
    可只给一侧, 如 b{2,} 表示最少2个b字符, b{,5}, 表示最多5个b字符, 也可指定数量, 如 b{2}
    惰性匹配,即符合条件的最短字符串,在量词后加 ? , 如 {m,n}?、{m,}?、??、+?、*?
      'ab(c(a1b1)1)23'.match(/(?<=\()(\n|.)*?(?=\))/g)    // c(a1b1
    不加时为贪婪匹配
      'ab(c(a1b1)1)23'.match(/(?<=\()(\n|.)*(?=\))/g)     // c(a1b1)1

  (2) [] 用于指定匹配的范围
    如 /a[123]b/ 指匹配 a开头,b结尾, 中间间隔 1或2或3
    - 可用于表示范围, 如 [123456abcdefGHIJKLM]可以写成[1-6a-fG-M], 如需匹配 - 字符, 可以用 - 转义, 或将 - 字符写于开头和结尾
    [^]可用来排除匹配范围, 如[^xy]表示非x且非y的所有字符

  (3) {} 和 [] 可以组合使用, 如 /a[12]{2,5}c/ 指匹配 a开头,b结尾, 中间间隔 2到5个字符 1或2
    {} 和 [] 不可嵌套使用, /a[2{1,4}]b/ 指匹配 a开头,c结尾, 中间间隔 2或{或1或,或4或}
    | 可用于设置多个匹配模式

元字符, 往往 \小写代表匹配, \大写代表不匹配
  \d 等价于 [0-9], \D 等价于 [^0-9], 匹配一位数字
  \t 水平制表符
  \v 垂直制表符
  \n 换行符
  \r 回车符
  \f 换页符
  \s 中英文空格、水平制表符、垂直制表符、换行符、回车符、换页符
  \S \s 外的其他字符
  \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
  . 除 \n 外的任意字符
  \b 单词开头或结尾的位置

限定符, 表示一个规则出现多少次才满足匹配
  {n} 出现 n 次
  {n,m} 出现 n 到 m 次(含)
  {n,} 至少出现 n 次(含)
  {,m} 最多出现 m 次(含)
  + 等价于 {1,}, 至少出现一次
  * 等价于 {0,}, 出现任意次(含0)
  ? 等价于 {0,1}, 表示出现或不出现

^ / $
  ^ 出现在正则的开始时, 代表匹配字符串是否以指定字符开头
    /^a/.test('abc12345')  // true
    /^1/.test('abc12345')  // false
  $ 出现在正则的末尾时, 代表匹配字符串是否以指定字符结尾
    /a$/.test('abc12345')  // false
    /5$/.test('abc12345')  // true

修饰符 i / g / m
  i 忽略大小写
  g 全局匹配                                                                        
  m 多行匹配

  (pattern) 获取匹配, 可用 RegExp.$1 ... $9 来获取匹配到的变量
    /(\d{4})-(\d{2})-(\d{2})/.test('2018-04-18')
    RegExp.$1   //2018
    RegExp.$2   //04
    RegExp.$3   //18

  (?:pattern) 非获取匹配 (含匹配字段)
    /(?:\d{4})-(\d{2})-(\d{2})/.test('2018-04-18')
    RegExp.$1   //04
    RegExp.$2   //18

    '2018-04-18'.match(/(?:\d{4})-(\d{2})-(\d{2})/g) // ["2018-04-18"]
    '2018-04-18'.match(/(?<=\d{4})-(\d{2})-(\d{2})/g) // ["-04-18"]

  (?=pattern) 正向肯定预查 (不含匹配字段)
    /my name is (?=baba)/.test('my name is baba')   // 查找后面跟着 baba 的 'my name is ' 片段, 结果为 true

  (?!pattern) 正向否定预查
    /my name is (?!baba)/.test('my name is baba')   // 查找后面不跟着baba 的 'my name is ' 片段, 结果为 false

  (?<=pattern) 反向肯定预查
    /(?<=my) name is baba/.test('my name is baba')   // 查找接在 my 之后的 ' name is baba' 片段, 结果为 true

  (?<!pattern) 反向否定预查
    /(?<!my) name is baba/.test('my name is baba')   // 查找不接在 my 开头的 ' name is baba' 片段, 结果为 false

  正向/反向 的意思是, pattern 之前/之后 的片段要满足需求
  如 /(?<= start )((\n|.)*?)(?= end )/ 表示匹配 在 start 之后且在 end 之前 的任意长度字符

实例
  匹配指定字符之间的内容(含) / start (\n|.)*? end /g
    'abc(a1b1)123'.match(/\((\n|.)*?\)/g) // (a1b1)
  
  匹配指定字符之间的内容(不含) 'abc(a1b1)123' => a1b1
    零宽断言(有浏览器兼容性问题) /(?<= start )((\n|.)*?)(?= end )/g

  replace 支持正则, 且可以使用匹配的到字符
    '/api/getData.json'.replace(/(\/|\.)/g, (c) => '\\'+c)  // \/api\/getData\.json

  整数千分位加逗号 '123456789' => '123,456,789'
    思路: 
      1. 取 以3位数字结尾的 数字, 即 /\d(?=\d{3}$)/ 这样可以拿到 6
      2. 取 以 (3位数字)*n 结尾的 数字, 即 /\d(?=(\d{3})+$)/ 这样可以拿到 3, 6
      3. replace 替换
    实现:
      '123456789'.replace(/\d(?=(\d{3})+$)/g, c => c+',')
      '123456789'.replace(/(?!^)(?=(\d{3})+$)/g, ',')
      分析
        /(?=(\d{3})$)/g  "123456,789"
        1. 用非捕获匹配 拿到以3个数字结尾的 位置
        /(?=(\d{3})+$)/g  ",123,456,789"
        2. 将匹配规则改为 以3的倍数个数字结尾
        /(?!^)(?=(\d{3})+$)/g
        3. 再把 出现在首位的位置 剔除掉

命名分组
  'aaaa'.replace(/(?<name>)\k<name>\1/, 'b') // bbba


零宽断言 存在浏览器兼容性问题 ?<=、?<!
√ 1、(?=xxx) 例：'doing'.match(/\b\w+(?=ing\b)/) => do，以ing结尾的单词的前面部分
x 2、(?<=xxx) 例：'rebuild'.match(/(?<=\bre)\w+\b/) => build 以re开头的单词的后半部分
√ 3、(?!xxx) 例：'1234a'.match(/\d{3}(?!\d)/) => 234 后面不是数字的三位数字
x 4、(?<!xxx) 例：'a12345678'.match(/(?<![a-z])\d{7}/) => 2345678 前面非小写字母的七位数字
