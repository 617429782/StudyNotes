## 美团
- 低代码平台建设

- 低代码引擎生态建设

## 爱逛
- node端日志治理
  1. 项目的背景
    日志是开发人员排查问题的重要手段，日志的基本要求是详细和完整
    现有的日志平台提供了日志采集SDK、日志检索、统计告警等功能
    我们作为业务方，决定日志的上报时机和方式
    因为平台对接全公司的项目, 在个性化需求和细分功能上并不完善, 比如
    (1) 对上报的日志内容、等级没有统一的规范和约束, 导致排查问题
    (2) 存在漏报的现象
    (3) 在推动错误的修复和治理上效果一般
  
  2. 如何解决上述问题
    (1) 收敛上报入口: 封装日志上报SDK, 统一做等级划分、内容格式化, 消除手动上报过于随意的问题
        日志的内容主要包含了 链路id、url及对应的路由回调方法名、用户信息、错误信息 等
        日志的等级划分主要是依据 请求状态、错误码、错误信息
    (2) 漏报主要是 try/catch 绕过了全量捕获
        重复上报是对日志分类引起的, 为了更快定位问题, 大体将日志分为 后端接口 和 前端处理 两类
        对调后端接口抛出的异常统一进行了手动catch和上报, 因为部分业务异常也被归为错误, 为了将信息抛给客户端层, 需要throw出去, 这触发了全量上报
        正确的做法应该是在 路由层 做catch, 以捕获数据处理部分的异常, 然后根据错误码决定是否继续 throw
        这部分目前做了排查和宣讲, 后续计划尝试用eslint插件来约束
    (3) 往往被关注的是量大到一定程度触发告警的错误, 但有些错误量少但不代表不重要, 但是目前的检索平台没有提供归类统计这样的功能
        所以写了一个爬虫, 拿到所有的错误日志, 按 url 分类统计次数, 再根据git提交记录拿到提交人, 推进错误治理
        但这又有个难点: 有赞node架构中 路由是通过 配置文件 声明的, 可能存在url对应的回调被改了, 但url本身没改, 导致提交人和责任人不符的情况
        解决的方案是引入 装饰器路由, 将url和路由回调写在一起, 通过文件行号查最近一次的提交人即可

  3. 装饰器路由怎么实现的
    (1) 有赞node架构要求 路由配置文件 export 一个 二维数组, 数组项包含 请求类型、url、controller相对路径、controller中对应的回调函数名
    (2) 装饰器函数在ts编译时被执行, 可以拿到 被装饰的函数名, 结合传入的 请求类型、url, 挂在 controller 的原型对象上
    (3) 提供一个扫描函数给, 其作用是遍历所有 controller 文件, 拿到挂在他们原型上的 路由列表, 和文件相对路径, 最终返回一个二维数组给 阿童木

  4. 有赞node架构
    (1) 阿童木是基于 koa 的脚手架, 提供了 对koa对象原型的扩展、约定配置、插件化、MVC模型 等功能
    (2) 对 koa 的扩展主要是对 ctx 挂了一些业务常用的属性和方法
    (3) 其插件化本质上类似 mixin, 是配合约定配置使用的, 其约定 特定功能的文件放在特定的目录, 比如 中间件、路由、config 等, 其loader会遍历指定的目录加载并合并
    (4) 匹配到路由的回调过程大致分为 controller、service、dubbo(dao) 层
        controller: 负责参数校验、接口聚合
        service: 负责业务处理
        dubbo: 调用后端接口
        在 node 和 java 层之间还有一个 代理层 tether
        其作用是 dubbo服务发现、负载均衡、维持长链接 等

  5. 日志采集方式
    (1) 所有的日志最终都是以http请求的方式上报到日志平台
    (2) 日志采集的方式一般有两种, 全量和手动
      全量上报因为基于koa, 有 app.onError 和 中间件 两种方式
      项目采用的是中间件的方式, 在路由中间件之前注册(理论上应该最先注册, 但怕中途有中间件catch后没有 throw), 以确保拿到业务处理抛出的异常
  
  6. 中间件的执行原理
    本质上是 发布订阅 + 递归, 用数组存放所有 use 注册的中间件, 触发时, 不断从中取出回调执行, 并将下一个中间件作为其next
    基本的实现 
      ```
        const middlewares = [];
        function use(cb) { middlewares.push(cb) }
        function callback(ctx) {
          function dispatch(index) {
            const fn = middlewares[i]
            return fn(ctx, dispatch.bind(null, i+1))
          }
          return dispatch(0)
        }
      ```

  7. 异步代码的错误捕获


- 爱逛小程序
  1. 需求背景/难点

  2. mixin 的实现原理
    0. behavior 存在哪些问题
      1. 不支持自定义字段如 store
      2. App、Page不能支持生命周期的复用 (Component 支持)
      3. (算作mixin的优点) 允许为 待混入的模块指定权重, 以改变覆盖规则
    1. 创建 页面 和 组件 实例时会传入一个 配置对象, 我们在这个 配置对象 中传入一个 特殊字段: mixin, 通过 import 引入需要混入的代码片段
    2. 劫持小程序原生的 App、Page、Component 构造函数, 使得 调用原生构造函数前 先 处理传入的配置对象
    3. 之后就是 对象 之间的 两两合并, 主要的场景有
      1. mixin 数组各项之间的合并
      2. mixin 多层嵌套的合并
      3. 传入的 mixin 与全局预置的配置合并 (logger、reguest、event-center、hook 等)
      4. mixin 引入的对象 与 定义在 option 中的同名属性的合并
    4. mixin 的覆盖规则 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html
      1. 属性(properties、observers、自定义字段等)、方法(methods)、特殊生命周期(如onShareAppMessage) (覆盖)
        组件 > behavior
        靠后的 behavior > 靠前的 behavior (数组项之间的合并)
        父 behavior > 子 behavior (嵌套合并)
      2. data 对象 (覆盖 / 合并): '引用类型' 进行递归合并, '常量类型' 进行覆盖, 覆盖规则为 (前面覆盖后面)
        组件 > 父 behavior > 子 behavior
        靠后的 behavior > 靠前的 behavior
      3. 生命周期 (合并): 不会相互覆盖, 而是在对应触发时机被逐个调用, 同名生命周期的执行顺序: 
        behavior -> 组件
        子 behavior -> 父 behavior
        靠前的 behavior -> 靠后的 behavior

  3. 自定义 hooks 的实现原理
    0. 相比于事件的无耦合, hook牺牲了一定的灵活性, 换取更好的可维护性
      1. 基于事件扩展功能时, 需要深入了解主流程的执行逻辑, 且侵入式的修改, 这违反了开闭原则
      2. 基于hook时, 只需要了解定义的钩子本身, 而不需要关注上下文 (这需要定义hook时充分考虑到 调用方需要的时机和参数)
    1. 使用方式与实现原理: 定义(new)、触发(call) + 注册(tap)
      1. 定义: 创建钩子实例, 确定触发时需要的参数, new SyncHook(['a', 'b', 'c', ...])
      2. 注册: 在钩子实例的回调列表中添加回调, 同时做一些异常处理 (是否定义过该钩子、是否注册了相同的回调等)
      3. 触发: 遍历并触发 回调列表
    2. 有哪些可用的钩子
      参考了 webpack 的 tapable, 提供了 三种同步 + 三种异步 钩子
      

## 海康#
- 信号机
  0. 项目的背景: 
    部门新开的产品线, 主要用于配合硬件, 给交通路口的红绿灯配置参数, 通过三维的动画场景, 给机关人员提供可视化的配置和交互能力
    做这个项目的目的是方便机关人员配置和监控数据, 从传统的表单、表格中解放出来, 尽可能做到一键配置、可视化

  1. websocket封装 做了哪些工作
    1. 基于发布订阅模式的事件机制
    2. 登陆鉴权/断线重连
    3. 数据加密
    4. 文件上传

  2. 断线重连怎么做的
    1. 客户端请求建立websocket连接
    2. 服务端返回 sessionID, 加盐随机串, 迭代次数, 约定加密方式
    3. 客户端发送加密后的用户名、密码, 服务端更新并返回token
    4. 客户端将token存入sessionStorage, 用于断线重连
    5. 服务端断开的连接
      监听 websocket 的 onclose 方法, 重新创建 ws 实例, 发送token
    6. 刷新页面导致的断开
      首次建连后将token写入 sessionStroage, 页面初始化时尝试从 sessionStroage 获取, 获取到则建立连接发送token获取 密钥

  3. 数据加密怎么做的
    1. 基于AES对称加密, 双方约定密钥的生成方式, 每次连接密钥都不同
      对称加密(双方约定密钥, 可逆, 速度快效率高, 密钥泄露会有安全问题): AES、DES
      非对称加密(公私钥, 更安全, 效率低): RSA、DSA
      数据摘要算法(不可逆, 用于数字签名、完整性校验等, 可能遭遇彩虹表的破解, 可配合其他方式一起使用): MD5、SHA256
    2. 密钥生成: 对登录密码+指定字符串进行指定次数的SHA256迭代, 生成一个不可逆的密钥, 作为AES加密的密钥

  4. 文件上传怎么做的
    1. 通过表单读取文件 e.target.files
    2. 通过 FileReader.readAsArrayBuffer 将文件内容转为 ArrayBuffer, 再转为 Uint8Array (之后可以用数组方法操作文件内容)
    3. 每次读取1M的二进制数据作为切片, 在头部插入序号、切片长度、起止位置等信息
    4. 如果有断点续传的需求, 服务端只需要把缺少的切片序号返回过来, 重新发送即可
    5. 完整性校验: 计算文件的md5摘要, 这部分属于长时间的同步任务, 需要放到 web-worker 中进行以避免阻塞
      const worker = new Worker(filePath) // 可以是本地文件, 也可以是网络文件, 但必须同源
      worker.onmessage = () => {} // 接受工作者线程通过 self.postMessage() 传过来的消息
      worker.postMessage()  // 向工作者线程发送数据, 线程内需要通过 self.addEventListener('message') 监听
  
  5. 为什么用websocket
    1. 双向传输, 项目中有服务端推送数据的需求
    2. 不需要http反复握手的过程, 速度更快
    3. 没有http头等附加信息, 数据量更小

  6. 为什么用 threeJS, 做了哪些事情
    1. threeJS 主要提供了三种能力
      1. 提供了 场景树节点 的操作能力, 增/删节点
      2. 将 场景树渲染到 canvas 的能力, 循环调用这个接口就形成了动画
      3. 提供了与 canvas 的交互能力
    2. 上述三种能力可以类比虚拟DOM的概念, 我们做的事情主要就是维护这颗 虚拟DOM树, 与我们的数据做映射
    3. 数据变化如果重新创建场景树代价较大, 因此引入了 diff 的概念, 找到需要变更的 场景节点

- 执法记录仪
  需求背景: 
    新产品, 使用场景为用户佩戴视频采集设备, 设备记录GPS信息、生成视频文件导入到服务器, 提供视频画面与行进轨迹回放的功能
  核心技术: 
    vue、openlayer
  工作内容: 
    1、Web端播放海康视频文件(特殊mp4, 需转码才可播放)的无插件预览方案的预研
    2、离线地图方案的预研
    3、Web端的设计与实现, 包括框架搭建, 各个模块的设计与编码
  心得体会: 
    1、基于 openlayer的离线地图 方案
    2、使用 nodeJs 搭建 http服务器, 加深了对 http协议 的理解
      (大文件播放时content-length无效, 但出现了Transfer-Encoding:chunked, 因为http协议规定当不能预先确定报文响应体的长度或者报文响应体的长度过大时, 无法使用content-length字段来指明报文长度, 需要通过Transfer-Encoding域来替代, 这个时候就需要等待视频文件全部加载完, 然后IE下的进度条也会失效)
      状态码设置为206, 使用缓冲区分批发送文件数据, 主要是 content-length 和 content-range 的设置, 第一次conteny-range设为 bytes 0-(tlength-1)/tlength), 此后每次浏览器都会返回 range 属性 byte=bstart-bend,
      服务端返回 conteny-range: bytes bstart-bend/f

      node使用了http模块和fs模块, 监听端口, response.writeHead 写响应头, fs读写文件流
    3、对于 Web端视频播放方案 的总结对比 (ocx、flash、video、canvas)

- 开发中遇到过哪些问题？
    使用 ThreeJS 时的内存泄露问题: 
      问题描述: 测试人员发现反复切换页面时, 有时会出现浏览器崩溃的现象
      排查过程: 
        1、复现: 目的确认是否是操作系统和浏览器兼容性问题, 发现并非兼容性原因, 从任务管理器的内存使用情况可以看到切换页面时内存在逐渐上涨, 并且没有明显的下降, 初步判断是内存泄露了
        2、定位(直接原因/根本原因): 从chrome控制台的内存快照功能可以看出, 页面切换时, ThreeJS创建的实例被多次创建, 并且没有被销毁
        3、分析: 每次创建网格体的时候, 其依赖的几何形状实例和材质实例都会重新创建(UUID不同), 但是在删除网格体时, 其依赖没有被自动删除, 依然存在于GPU显存里
        4、解决(临时方案/根本方案): 事先创建网格体的依赖实例, 然后每次创建网格体实例时克隆依赖实例(克隆出来的实例是不同的, 但是其依赖是相同的), 并且在网格体被删除的时候手动调用依赖的销毁方法

