## 美团
- 研发效率度量
  - 项目难点
    - 源码和低代码开发方式的差异，需要设计一套公平的算法
    - 准确性，如何排除干扰因素
    - 能够具备多维度的分析能力
  - 算法基本思路
    - 开发周期的确定 => 低代码页面创建/发布；源码git记录中路由的增加和发布；
    - 开始耗时的计算 => 低代码页面保存、定时diff；源码定时采集文件改动，基于文件引用关系识别页面相关改动；
    - 对干扰项的排除 => 分区密度权重算法，4小时为区，0.25～3的密度权重为0.1～1，呈对数曲线；

- 低代码生态建设
  - 建设低代码引擎的背景和目标
    - 规范和标准 => 性能、质量、维护成本
    - 面向不同场景，提供快速孵化编辑器的能力，减少重复造轮子的成本

  - 与阿里低代码引擎的异同
    - 引擎层面
      技术栈差异
      核心功能一致
      体验上的扩展：
        - UI骨架扩展 面板关闭按钮、二级面板
        - 拖拽缩略图 模拟拖拽缩略图
        - 事件系统区分 内置/用户（规划）
    - 协议层面
      - 渲染时 Schema 语法不变
      - 编辑时 扩展私有协议，用于辅助编排，在模型层转 schema 时加入转换钩子
    - 设计器(编辑器)层面
      - 全套自研的插件，包括 xxx、xxx 等
    
  - 业务方情况介绍
    - 面向中后台场景，150+活跃用户、300+项目、2000+页面；职能涵盖 前端、后端、QA；未来计划覆盖产品、运营和 C端场景
    - 活动用例
      - 接入: 在线接入、存量项目改造；提供数据托管、请求代理、公司级基建接入等能力；
      - 编排: UI编排(模版、业务组件、画布操作)、逻辑编排(内置动作、自定义动作、可视化动作编排)、智能化助手(探索中)；
      - 部署: 分环境部署、审批、历史记录查询；
    - 页面加载流程
      - 环境准备: 请求 系统信息、页面信息、资源版本信息
      - 资源加载: 动态加载资源，全局注册组件
      - 页面渲染: 渲染器解析 schema，渲染成 DOM

  - 项目难点
    - 技术实现层面，大部分问题我们都可以参考阿里引擎解决，主要看熟悉程度，但有两个明显的问题需要解决
      1. 私有协议的兼容，比如动作编排，需要兼顾协议的流通性和原有功能的完整性，解决思路是在模型层转协议时加入钩子，通过高阶函数的方式支持私有功能
      2. 升级的稳定性保障，底层实现的重构需要尽可能做到用户无感知，保障版本平滑过渡
    
  - 未来规划
    1. 性能瓶颈 => 组件化的能力、出码
    2. 质量保障 => 提升代码的可测试性、围绕 VNode 比对工具实现自动化测试
    3. 功能 => 更多场景的探索: C端H5、楼层编排、数据可视化的场景等等, 对可视化编排的支持

  1. 历史包袱的根源 => 性能、稳定性差，容易出事故，技术支持投入成本高
    - 缺少对开发者的管控，缺少私有API的设计，导致底层变更带来兼容性问题 => 信息缺失的暗坑
    - 缺少类型约束、单测的保障 => 自身的逻辑 bug
    - 人员流动导致设计理念和开发质量参差不齐，维护困难 => 标准和规范的缺失

  2. 性能优化
    - 关注指标: INP(交互到绘制) 95线，发现长尾页面后会介入分析页面的特征、制定优化手段，采集方案是组件更新耗时
    - 优化的结果: 均值由 700ms 降到 350ms左右，95线由 4000ms 降到 1000ms 左右
    - 优化手段: https://km.sankuai.com/collabpage/1938236783
      缩减渲染内容: 减少页面中的 vnode 数量，对于不可见的部分(比如弹窗组件)，用 v-if 优化
      精简渲染过程: 运行时逻辑，将部分功能移到编译时

  3. 质量保障
    - 输出指标: 月均缺陷的数据
    - 输入指标: 
    - 保障手段: 
    todo: 主动防御的策略: 异常监控、单测、升级预检测(自动化测试)评估升级风险
    todo: 预检测前后的页均问题数量

    - 版本控制: 升级选择权给到开发者，避免直接影响生产环境。
    - 预升级: 匹配升级前后 vnode 变化，评估风险，降低开发者的回归成本。

  4. 低代码引擎架构
    - UI骨架模块：
      - 物料面板、动作面板、数据源面板、代码编辑器
    - 编排模块
      - 模型设计
      - 拖拽引擎
      - 画布工具
    - 渲染模块
    - 设置器模块
    - 插件模块 => 提供 API 供开发者操作私有模块

  5. 流程编辑器
    - 渲染层库用的是 jointjs，有点像 d3 和 g6，基于 SVG，有一套模型和事件体系
    - 收益模型: 
      统计公式: 改造前一年在活动配置需求中投入的前端人力(334) - 改造后投入的前端人力(35.5);
      理论依据: 由于业务的定制性和实效性，用传统表单页承接活动配置时，具有复杂度高、灵活性低、复用性低等弊端；活动的环节越多，调整的成本就越高；而流程编排的数据模型和可视化的操作能力提供了高度的灵活性，很大程度上降低了活动模版的开发成本;
    
  6. 渲染器介绍
    - 功能: 做的是模版编译的工作，将一段 JSON 解析为 Vue 的 render 函数，其中包括 变量/动作处理、生命周期处理、条件/循环渲染、插槽渲染、组件属性/样式/事件解析
    - 定位: 保障
    - 

## 爱逛
- node端日志治理
  1. 项目的背景
    日志是开发人员排查问题的重要手段，日志的基本要求是详细和完整
    现有的日志平台提供了日志采集SDK、日志检索、统计告警等功能
    我们作为业务方，决定日志的上报时机和方式
    因为平台对接全公司的项目, 在个性化需求和细分功能上并不完善, 比如
    (1) 对上报的日志内容、等级没有统一的规范和约束, 导致排查问题
    (2) 存在漏报的现象
    (3) 在推动错误的修复和治理上效果一般
  
  2. 如何解决上述问题
    (1) 收敛上报入口: 封装日志上报SDK, 统一做等级划分、内容格式化, 消除手动上报过于随意的问题
        日志的内容主要包含了 链路id、url及对应的路由回调方法名、用户信息、错误信息 等
        日志的等级划分主要是依据 请求状态、错误码、错误信息
    (2) 漏报主要是 try/catch 绕过了全量捕获
        重复上报是对日志分类引起的, 为了更快定位问题, 大体将日志分为 后端接口 和 前端处理 两类
        对调后端接口抛出的异常统一进行了手动catch和上报, 因为部分业务异常也被归为错误, 为了将信息抛给客户端层, 需要throw出去, 这触发了全量上报
        正确的做法应该是在 路由层 做catch, 以捕获数据处理部分的异常, 然后根据错误码决定是否继续 throw
        这部分目前做了排查和宣讲, 后续计划尝试用eslint插件来约束
    (3) 往往被关注的是量大到一定程度触发告警的错误, 但有些错误量少但不代表不重要, 但是目前的检索平台没有提供归类统计这样的功能
        所以写了一个爬虫, 拿到所有的错误日志, 按 url 分类统计次数, 再根据git提交记录拿到提交人, 推进错误治理
        但这又有个难点: 有赞node架构中 路由是通过 配置文件 声明的, 可能存在url对应的回调被改了, 但url本身没改, 导致提交人和责任人不符的情况
        解决的方案是引入 装饰器路由, 将url和路由回调写在一起, 通过文件行号查最近一次的提交人即可

  3. 装饰器路由怎么实现的
    (1) 有赞node架构要求 路由配置文件 export 一个 二维数组, 数组项包含 请求类型、url、controller相对路径、controller中对应的回调函数名
    (2) 装饰器函数在ts编译时被执行, 可以拿到 被装饰的函数名, 结合传入的 请求类型、url, 挂在 controller 的原型对象上
    (3) 提供一个扫描函数给, 其作用是遍历所有 controller 文件, 拿到挂在他们原型上的 路由列表, 和文件相对路径, 最终返回一个二维数组给 阿童木

  4. 有赞node架构
    (1) 阿童木是基于 koa 的脚手架, 提供了 对koa对象原型的扩展、约定配置、插件化、MVC模型 等功能
    (2) 对 koa 的扩展主要是对 ctx 挂了一些业务常用的属性和方法
    (3) 其插件化本质上类似 mixin, 是配合约定配置使用的, 其约定 特定功能的文件放在特定的目录, 比如 中间件、路由、config 等, 其loader会遍历指定的目录加载并合并
    (4) 匹配到路由的回调过程大致分为 controller、service、dubbo(dao) 层
        controller: 负责参数校验、接口聚合
        service: 负责业务处理
        dubbo: 调用后端接口
        在 node 和 java 层之间还有一个 代理层 tether
        其作用是 dubbo服务发现、负载均衡、维持长链接 等

  5. 日志采集
    (1) 所有的日志最终都是以http请求的方式上报到日志平台
    (2) 日志采集的方式一般有两种, 全量和手动
      全量上报因为基于koa, 有 app.onError 和 中间件 两种方式
      项目采用的是中间件的方式, 在路由中间件之前注册(理论上应该最先注册, 但怕中途有中间件catch后没有 throw), 以确保拿到业务处理抛出的异常
  
  6. 中间件的执行原理
    本质上是 发布订阅 + 递归, 用数组存放所有 use 注册的中间件, 触发时, 不断从中取出回调执行, 并将下一个中间件作为其next
    基本的实现 
      ```
        const middlewares = [];
        function use(cb) { middlewares.push(cb) }
        function callback(ctx) {
          function dispatch(index) {
            const fn = middlewares[i]
            return fn(ctx, dispatch.bind(null, i+1))
          }
          return dispatch(0)
        }
      ```

- 爱逛小程序
  1. 需求背景/难点
    打包构建 => 基于 webpack，先用 mini-program-webpack-loader 插件做一次编译，再交由小程序编译器处理
    状态管理
    逻辑复用
    事件系统

  2. mixin 的实现原理
    0. behavior 存在哪些问题
      1. 不支持自定义字段如 store
      2. App、Page不能支持生命周期的复用 (Component 支持)
      3. (算作mixin的优点) 允许为 待混入的模块指定权重, 以改变覆盖规则
    1. 创建 页面 和 组件 实例时会传入一个 配置对象, 我们在这个 配置对象 中传入一个 特殊字段: mixin, 通过 import 引入需要混入的代码片段
    2. 劫持小程序原生的 App、Page、Component 构造函数, 使得 调用原生构造函数前 先 处理传入的配置对象
    3. 之后就是 对象 之间的 两两合并, 主要的场景有
      1. mixin 数组各项之间的合并
      2. mixin 多层嵌套的合并
      3. 传入的 mixin 与全局预置的配置合并 (logger、reguest、event-center、hook 等)
      4. mixin 引入的对象 与 定义在 option 中的同名属性的合并
    4. mixin 的覆盖规则 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html
      1. 属性(properties、observers、自定义字段等)、方法(methods)、特殊生命周期(如onShareAppMessage) (覆盖)
        组件 > behavior
        靠后的 behavior > 靠前的 behavior (数组项之间的合并)
        父 behavior > 子 behavior (嵌套合并)
      2. data 对象 (覆盖 / 合并): '引用类型' 进行递归合并, '常量类型' 进行覆盖, 覆盖规则为 (前面覆盖后面)
        组件 > 父 behavior > 子 behavior
        靠后的 behavior > 靠前的 behavior
      3. 生命周期 (合并): 不会相互覆盖, 而是在对应触发时机被逐个调用, 同名生命周期的执行顺序: 
        behavior -> 组件
        子 behavior -> 父 behavior
        靠前的 behavior -> 靠后的 behavior

  3. 自定义 hooks 的实现原理
    0. 相比于事件的无耦合, hook牺牲了一定的灵活性, 换取更好的可维护性
      1. 基于事件扩展功能时, 需要深入了解主流程的执行逻辑, 且侵入式的修改, 这违反了开闭原则
      2. 基于hook时, 只需要了解定义的钩子本身, 而不需要关注上下文 (这需要定义hook时充分考虑到 调用方需要的时机和参数)
    1. 使用方式与实现原理: 定义(new)、触发(call) + 注册(tap)
      1. 定义: 创建钩子实例, 确定触发时需要的参数, new SyncHook(['a', 'b', 'c', ...])
      2. 注册: 在钩子实例的回调列表中添加回调, 同时做一些异常处理 (是否定义过该钩子、是否注册了相同的回调等)
      3. 触发: 遍历并触发 回调列表
    2. 有哪些可用的钩子
      参考了 webpack 的 tapable, 提供了 三种同步 + 三种异步 钩子  

## 海康
- 信号机
  0. 项目的背景: 
    部门新开的产品线, 主要用于配合硬件, 给交通路口的红绿灯配置参数, 通过三维的动画场景, 给机关人员提供可视化的配置和交互能力
    做这个项目的目的是方便机关人员配置和监控数据, 从传统的表单、表格中解放出来, 尽可能做到一键配置、可视化

  1. websocket封装 做了哪些工作
    1. 基于发布订阅模式的事件机制
    2. 登陆鉴权/断线重连
    3. 数据加密
    4. 文件上传

  2. 断线重连怎么做的
    1. 客户端请求建立websocket连接
    2. 服务端返回 sessionID, 加盐随机串, 迭代次数, 约定加密方式
    3. 客户端发送加密后的用户名、密码, 服务端更新并返回token
    4. 客户端将token存入sessionStorage, 用于断线重连
    5. 服务端断开的连接
      监听 websocket 的 onclose 方法, 重新创建 ws 实例, 发送token
    6. 刷新页面导致的断开
      首次建连后将token写入 sessionStroage, 页面初始化时尝试从 sessionStroage 获取, 获取到则建立连接发送token获取 密钥

  3. 数据加密怎么做的
    1. 基于AES对称加密, 双方约定密钥的生成方式, 每次连接密钥都不同
      对称加密(双方约定密钥, 可逆, 速度快效率高, 密钥泄露会有安全问题): AES、DES
      非对称加密(公私钥, 更安全, 效率低): RSA、DSA
      数据摘要算法(不可逆, 用于数字签名、完整性校验等, 可能遭遇彩虹表的破解, 可配合其他方式一起使用): MD5、SHA256
    2. 密钥生成: 对登录密码+指定字符串进行指定次数的SHA256迭代, 生成一个不可逆的密钥, 作为AES加密的密钥

  4. 文件上传怎么做的
    1. 通过表单读取文件 e.target.files
    2. 通过 FileReader.readAsArrayBuffer 将文件内容转为 ArrayBuffer, 再转为 Uint8Array (之后可以用数组方法操作文件内容)
    3. 每次读取1M的二进制数据作为切片, 在头部插入序号、切片长度、起止位置等信息
    4. 如果有断点续传的需求, 服务端只需要把缺少的切片序号返回过来, 重新发送即可
    5. 完整性校验: 计算文件的md5摘要, 这部分属于长时间的同步任务, 需要放到 web-worker 中进行以避免阻塞
      const worker = new Worker(filePath) // 可以是本地文件, 也可以是网络文件, 但必须同源
      worker.onmessage = () => {} // 接受工作者线程通过 self.postMessage() 传过来的消息
      worker.postMessage()  // 向工作者线程发送数据, 线程内需要通过 self.addEventListener('message') 监听
  
  5. 为什么用websocket
    1. 双向传输, 项目中有服务端推送数据的需求
    2. 不需要http反复握手的过程, 速度更快
    3. 没有http头等附加信息, 数据量更小

  6. 为什么用 threeJS, 做了哪些事情
    1. threeJS 主要提供了三种能力
      1. 提供了 场景树节点 的操作能力, 增/删节点
      2. 将 场景树渲染到 canvas 的能力, 循环调用这个接口就形成了动画
      3. 提供了与 canvas 的交互能力
    2. 上述三种能力可以类比虚拟DOM的概念, 我们做的事情主要就是维护这颗 虚拟DOM树, 与我们的数据做映射
    3. 数据变化如果重新创建场景树代价较大, 因此引入了 diff 的概念, 找到需要变更的 场景节点

- 执法记录仪
  需求背景: 
    新产品, 使用场景为用户佩戴视频采集设备, 设备记录GPS信息、生成视频文件导入到服务器, 提供视频画面与行进轨迹回放的功能
  核心技术: 
    vue、openlayer
  工作内容: 
    1、Web端播放海康视频文件(特殊mp4, 需转码才可播放)的无插件预览方案的预研
    2、离线地图方案的预研
    3、Web端的设计与实现, 包括框架搭建, 各个模块的设计与编码
  心得体会: 
    1、基于 openlayer的离线地图 方案
    2、使用 nodeJs 搭建 http服务器, 加深了对 http协议 的理解
      (大文件播放时content-length无效, 但出现了Transfer-Encoding:chunked, 因为http协议规定当不能预先确定报文响应体的长度或者报文响应体的长度过大时, 无法使用content-length字段来指明报文长度, 需要通过Transfer-Encoding域来替代, 这个时候就需要等待视频文件全部加载完, 然后IE下的进度条也会失效)
      状态码设置为206, 使用缓冲区分批发送文件数据, 主要是 content-length 和 content-range 的设置, 第一次conteny-range设为 bytes 0-(tlength-1)/tlength), 此后每次浏览器都会返回 range 属性 byte=bstart-bend,
      服务端返回 conteny-range: bytes bstart-bend/f

      node使用了http模块和fs模块, 监听端口, response.writeHead 写响应头, fs读写文件流
    3、对于 Web端视频播放方案 的总结对比 (ocx、flash、video、canvas)

- 开发中遇到过哪些问题？
    使用 ThreeJS 时的内存泄露问题: 
      问题描述: 测试人员发现反复切换页面时, 有时会出现浏览器崩溃的现象
      排查过程: 
        1、复现: 目的确认是否是操作系统和浏览器兼容性问题, 发现并非兼容性原因, 从任务管理器的内存使用情况可以看到切换页面时内存在逐渐上涨, 并且没有明显的下降, 初步判断是内存泄露了
        2、定位(直接原因/根本原因): 从chrome控制台的内存快照功能可以看出, 页面切换时, ThreeJS创建的实例被多次创建, 并且没有被销毁
        3、分析: 每次创建网格体的时候, 其依赖的几何形状实例和材质实例都会重新创建(UUID不同), 但是在删除网格体时, 其依赖没有被自动删除, 依然存在于GPU显存里
        4、解决(临时方案/根本方案): 事先创建网格体的依赖实例, 然后每次创建网格体实例时克隆依赖实例(克隆出来的实例是不同的, 但是其依赖是相同的), 并且在网格体被删除的时候手动调用依赖的销毁方法


## 未来的职业规划
- 突出要点: 自我认知、对岗位职责的解读
- 模版: 
  我选择前端这份工作，更多是因为兴趣，我把它视为一门艺术，从中感受到快乐；所以对我而言，我希望能有一个志同道合的团队和氛围，在彼此的交流和碰撞中不断成长，追求卓越，用技术驱动业务，给用户带来极致的体验，甚至有一天我们可以通过技术去改变世界。
  但我目前距离这个目标还差得很远，所以需要在技术的深度和广度上持续深挖，往架构师的方向发展。我之前的工作经历主要是数据可视化、业务开发、低代码，如果有机会扩宽视野，在跨端、服务端、工程化这些方面，去了解在这种用户体量下，会遇到哪些系统性的问题以及如何去解决是很有意思的一件事。
  所以短期内，我会先学习和了解团队的目标、现状，观察流程上是否有改进和提效的空间。
  中长期，我会持续提升信息收集和对外输出的能力，和团队一起成长。
