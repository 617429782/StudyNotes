## 首屏时长优化
  1. 首屏时长计算公式
  2. 

## 打包优化
  1. tree-sharking: 去除不可能执行、未使用的代码
    主要是清除无用的 文件模块 // todo: 假如没有 tree-sharking，这部分会在打包成 bundle 时被添加进来吗？
    文件中部分通常在开发阶段就可以被 eslint 插件拦截
  2. 压缩混淆
  3. 代码分割: 三种实现
    1. 入口文件定义
    2. CommonsChunkPlugin 插件: 将被多次依赖的模块抽成一个 bundle
    3. 动态导入 import() 语法: 对这方式加载的模块，webpack会将其单独抽成 bundle

## 网络优化
  1. 减少资源大小和请求次数(代码合并压缩、雪碧图等)
  2. 合理利用缓存(预加载)
  3. DNS预解析
    <meta http-equiv="x-dns-prefetch-control" content="on" /> 开启预解析
    <link rel="dns-prefetch" href="www.test.com" /> 对指定域名做解析 
  4. CDN 

## 代码优化 
  1. JS层面
    1. 避免重绘回流，需要注意的操作有
      1. 对dom结构的修改(width/height/margin/padding/left/top/border等)引发尺寸变化
      2. 增/删/移动 DOM节点
      3. 读写offset、scroll、client等属性时, 浏览器为了获取值也需要回流
      4. 调用 window.getComputedStyle 方法
      5. 减少先读后写造成无效渲染，可以读后，用 requestAnimationFrame 在下一帧写
    2. 防抖/节流，针对不可避免的上述操作可以减少执行频率
    3. 事件委托
      通过 e.target 来确定当前点击的是哪个元素
    4. 使用局部变量
      基于垃圾回收中对新生代和老生代内存的不同操作，局部变量可以更快被回收以减少内存使用
    5. 用web-worker执行耗时的同步任务

  2. CSS 层面
    1. 减少CSS选择器的嵌套，css的计算规则是从右到左寻找所有符合条件的DOM，嵌套越深计算次数越多
    2. 提升图层，利用GPU加速改善动画流畅度
      transform
      will-change

  3. 框架层面
    1. react

    2. vue

    3. 小程序