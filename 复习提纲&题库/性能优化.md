## 解题思路
  

## 重点关注指标
  1. TTI: 
  2. INP: 
  
## 浏览器 性能API performance
  [Web页面全链路性能优化指南](https://mp.weixin.qq.com/s/IZEjbVbBmPlMGRw0fpyl_Q)
  1. TTFB: 首字节(请求发起到返回首字节) timing.responseStart - timing.requestStart
  2. FP: 首次绘制(首个像素绘制完成时间) performance.getEntriesByType('paint')[0].startTime
  3. FCP: 首次内容绘制 performance.getEntriesByType('paint')[1].startTime
  4. FMP: 首次有效绘制 
  5. TTI: 可交互时间（DOM树构建完毕） timing.domInteractive - timing.fetchStart
  6. LCP: 最大内容渲染（viewport中最大的页面元素加载的时间）
  7. FID: 首次输入延迟（首次交互 => 浏览器能够访问）
  8. 白屏时间: 输入网址 => 页面开始显示内容
    <head> 中插入脚本: Data.now() - performance.timing.navigationStart
  9. 首屏时间: 输入网址 => 首屏内容完成渲染, 包括图片、样式表、脚本等静态资源完成加载
    window.onload: Data.now() - performance.timing.navigationStart
  10. INP: 网页交互到下一次绘制的时间

## 网络优化
  1. dns 预解析: 让浏览器对 后续可能访问的网站 提前进行DNS解析
    <meta http-equiv="x-dns-prefetch-control" content="on" /> 开启预解析
    <link rel="dns-prefetch" href="www.test.com" /> 对指定域名做解析
  2. cdn 技术: 在距离用户地理位置近的 DNS服务端 缓存域名解析结果 
  3. 减少资源大小和请求次数(代码合并压缩、雪碧图等)
    a. 强缓存
    b. 压缩合并、tree-sharking
    c. server worker 缓存 (todo)
  4. 服务端渲染

## 打包优化
  1. tree-sharking: 降低未使用代码覆盖率
  2. 压缩混淆
  3. 代码分割: 减少首屏内容
    1. 入口文件定义
    2. CommonsChunkPlugin 插件: 将被多次依赖的模块抽成一个 bundle
    3. 动态导入 import() 语法: 对这方式加载的模块，webpack会将其单独抽成 bundle

## 代码优化 https://mp.weixin.qq.com/s/LE6MYT6ufALYroe5pwmqeg
  1. JS层面
    1. 避免重绘回流，需要注意的操作有
      1. 对dom结构的修改(width/height/margin/padding/left/top/border等)引发尺寸变化
      2. 增/删/移动 DOM节点
      3. 读写offset、scroll、client等属性时, 浏览器为了获取值也需要回流
      4. 调用 window.getComputedStyle 方法
      5. 减少先读后写造成无效渲染，可以读后，用 requestAnimationFrame 在下一帧写
    2. 防抖/节流，针对不可避免的上述操作可以减少执行频率
    3. 事件委托: 利用事件冒泡在上层元素做事件分发减少开销, 通过 e.target 来确定当前点击的是哪个元素
    4. 使用局部变量
      基于垃圾回收中对新生代和老生代内存的不同操作，局部变量可以更快被回收以减少内存使用
    5. 用 web-worker 执行耗时的同步任务
    6. 虚拟列表
    7. 动态加载组件
    8. 异步加载脚本: async 加载后立即执行、defer 在 DOMContentLoad 后执行
    9. 图片懒加载
    10. 骨架屏
    11. 预渲染？

  2. CSS 层面
    1. 减少CSS选择器的嵌套，css的计算规则是从右到左寻找所有符合条件的DOM，嵌套越深计算次数越多
    2. 提升图层，利用GPU加速改善动画流畅度
      transform、will-change 等关键属性
  
## SSR
  1. 定义: 在服务端完成 组件渲染 和 html生成 并发送给浏览器，在客户端完成交互事件和状态的绑定
  2. 优势:
    有利于 SEO: 爬虫不会等待数据请求完成，因此需要尽早提供 html 内容。
    更快的首屏加载: 更快的数据准备、无需等待所有 JS 执行完成。
  3. 劣势:
    对服务端要求高，在流量大的场景下需要考虑 缓存、负载均衡，避免 CPU 消耗过大。
    使用限制: 生命周期、三方库的兼容。
    依赖 node 环境。
  4. 实现原理: 

    [Vue-SSR](https://cn.vuejs.org/guide/scaling-up/ssr)
    [Vue SSR深度剖析](https://juejin.cn/post/6844903812700831757)
    [边缘渲染在首屏性能优化上的尝试与突破](https://mp.weixin.qq.com/s/kdkxhRGuHS8Svg8iNERQHA)
    [当页面渲染遇上边缘计算](https://mp.weixin.qq.com/s/y38l12pTBM5YePCmC6IXaQ)
    [谷歌工程师分享前端性能优化，渐进式](https://mp.weixin.qq.com/s/LDRc1MBCk9HMDMzrLPAiuA)
    [Vue SSR 性能优化实践](https://mp.weixin.qq.com/s/BC8gTS6hUtz1tmEvVZOZEA)
    [从四个方面帮你做好移动页面性能优化](https://mp.weixin.qq.com/s/ff0SyHcmwtsWZwOX9rya9Q)
    [React Server Component: 混合式渲染](https://mp.weixin.qq.com/s/NV-9MsZDamIV-alk1XUBqQ)
    [CSR、SSR、NSR、ESR](https://mp.weixin.qq.com/s/MZRZxmXSoAnGln5podQIKw)
    [SSR解决了什么问题？有做过SSR吗？你是怎么做的？](https://mp.weixin.qq.com/s/wARktKyXpGb1RtDk2ybDOA)