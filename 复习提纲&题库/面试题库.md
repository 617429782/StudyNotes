## 主流前端框架
- Vue 与 React 差异
  1. React 的定位是 UI 渲染库，是规范的制定者，配套设施由社区提供；Vue 的定位是开发框架，为开发者服务，相比而言，react 门槛和心智负担更高，需要开发者关注一些性能优化。
  2. 数据处理策略：Vue 数据响应式，更新以组件为粒度；React 数据不可变，单向数据流，更新自根组件开始。
  3. React 通过 fiber 的方式拆分渲染任务，以在页面节点量大的时候获取更好的用户体验。
  4. Vue 提供了模版和指令来实现语法糖，以及在编辑阶段制定优化策略；而 React 推荐使用 JSX 来获取更接近 JS 的编码体验。
  5. 交互事件处理上，React 通过事件委托的方式，分发合成事件，具有更好的浏览器兼容性和性能。

- Vue 和 React diff 算法的差异: [数组的双指针、链表的下标对比]
  1. 传统 diff 需要树的横纵两次遍历，以及 children 的比对，因此复杂度是 O(n3)。
  2. Vue2 是数组遍历，采用同层双端指针来提速，复杂度是 O(n)，通过比较 key、tag、数量来确定增删或者复用。
  3. React 是链表遍历，因此用的是[浮标递增法](https://www.zhihu.com/question/66851503)，通过判断节点在新旧链表中的下标是否相同来确定操作类型。

- Vue2 的响应式原理: [观察者模式的自动化实现]
  1. Vue 组件会在初始化阶段对传入的 data 进行响应式改造, 为其创建一个 Dep 实例，并通过属性描述符重写 get 和 set 操作，在 get 时将处于监听状态的 watcher 纳入 subs 列表，在 set 时执行 Dep.notify，依次触发 subs 中 watcher 的 update 方法。
  2. 在组件挂载、watch、computed 等场景会为订阅者创建一个 Watcher 实例，Watcher 被创建时会更新其 value，调用 Watcher.get，期间处于监听状态，Dep.target 会被设置成 Watcher 本身, 同时调用 Watcher.getter 来触发 target.getter 来完成依赖收集。
  3. 对象的属性变化通过 $set、$delete 手动触发，数组变化则通过劫持 pop、push 等原型方法触发。

- Vue3 新特性: [响应式重写、静态分析、组合式 API]
  1. 响应式系统重写
    Vue2 是对原数据的深度改造，采用 defineProperty 收集和触发依赖，对于引用类型需要额外的处理
    Vue3 是为原数据创建一个代理对象，天然支持对象的属性操作，但需要关注解构这类行为丢失响应式
  2. 静态分析
    静态提升（区分动态片段和静态片段）：提升静态内容到 render 范围外进行复用，直接通过 innerHTML 挂载，而不是 patch
    更新类型标记（进一步区分动态片段）：分析元素的动态部分，比如 :class, 在 createElementVNode 时传入 第四个参数，标记更新的类型，这里用了位运算来合并多种标记
    树结构打平（动态内容的针对性优化）：对于区块节点(无 if、for)在编译时忽视树形结构，将后代中的动态节点以数组方式存放，这在DOM层级深的情况下 diff 效率更高
  3. 组合式 API
    提供另一个逻辑复用方式，解决 Mixin 相互依赖、冲突 和 options 逻辑关注点分散 等开发者体验问题
    更有利于 TS 类型检查
  
- 简述 React fiber 原理
  1. 背景：React 在数据变化时，会从根节点开始渲染，在页面内容较多时，会因为 patch 操作耗时过久导致丢帧，因此需要可以一种可中断的 patch 手段。
  2. 实现：React 用链表去描述 VNode tree，可以在任意节点中断后，找到下一个节点继续工作。同时 React 基于任务优先级来进行调度，这使得 react 可以利用帧空闲时段做计算，避免跟GUI线程抢占资源。

- React 常见 Hook 的实现原理
  1. useState：闭包一个 数组 管理 本次 render 的所有 state，每次 useState 被调用，都会在 数组 中 push 一项。
  2. useEffect：todo

- 为什么不要在循环、条件语句或嵌套函数中调用 Hooks？
  1. 以 useState 为例, 其闭包了一个 数组 用于管理本次 render 所用到的 state, 如果在条件语句中使用, 则有可能导致 前后数组长度不一致 而更新错乱。

- [React setState](https://zhuanlan.zhihu.com/p/39512941) 做了什么，它是同步执行还是异步执行？=> [更新队列、合成/原生事件]
  1. setState 的作用是将 传入的对象 与 当前状态 合并, 重新进行渲染。
  2. 在 合成事件 和 钩子函数 中, setState 是异步的, 因为 React 会用更新队列缓存来合并重复的 render。
  3. 在 原生事件 和 setTimeout 中是同步的, 因为上下文的丢失, 他们不参与合并。

- 简述 React 的合成事件: [事件委托、合成事件、事件池（todo）]
  1. React 通过事件委托的方式，在根节点统一监听交互事件，待事件冒泡到根节点时，从触发事件的 fiber 开始往上逐层触发注册的事件回调（捕获模式时从上往下），这能降低创建事件对象所需的开销。
  2. 另外，根节点监听的是 React 的合成事件而非浏览器原生事件，这具有更好的跨浏览器兼容性，还自动为 注册的回调 绑定了组件作为上下文。
  3. 事件池：todo

- 介绍 React 中的逻辑复用方式: [Mixin、HOC、Hooks]
  1. mixin 是 react 早期（15 版本）提供的逻辑复用方式，本质上是 merge 配置项的过程，问题是多个 mixin 容易产生依赖和冲突, 不易维护。
  2. HOC 的本质是纯函数，旨在不侵入原组件的前提下实现扩展，需要依赖一些约定（比如透传无关的 props：<WrappedComponent {...this.props} {...newProps}/>），多层嵌套的情况下维护比较困难。
  3. Hooks 是当前主推的逻辑复用方式，解决了 mixin 逻辑关注点分散的问题，开发体验更好，同时还为函数组件提供了状态维护的能力。

- React 函数组件 vs 类组件: [面向对象/过程、this、逻辑复用]
  1. 类组件面向对象, 需要更重的心智；函数组件面向过程, 注重逻辑的纯粹。
  2. 函数组件没有 this、没有生命周期、没有 state, 只根据传入数据完成渲染, 功能更纯粹。
  3. 在 类组件 中, 同一职责的代码可能会被拆分到不同的生命周期函数中, 不同的生命周期也可能多次处理重复逻辑, 可维护性差。

- React 的 Concurrent（并发）模式？
  1. todo

- Vue-SSR 的原理，相比 CSR 的优劣
  1. todo

- Vue-router hash 模式和 history 模式的原理和差别
  1. hash 模式通过监听 hashChang 事件实现
  2. history 模式通过劫持

## Node
- 主流 Node 端框架: express、koa、egg、nest
  1. express: 对 node.http 回调的封装, 提供了 路由、中间件、模版引擎 等功能。
  2. koa: 相比 express 仅保留中间件逻辑，不内置 路由、模版引擎 等功能。中间件采用洋葱模型，同时在异常处理上更友好。
  3. egg: 对 koa 的封装，MVC 开发模式，约定大于配置，提供 Loader 加载并整合特定目录/名称的文件，提供插件机制作为扩展配置的单元，相比直接修改配置或者增加中间件，插件提供是否启用、加载顺序等精确控制。
  4. nest: 通过模块和装饰器处理事务，依赖注入和控制反转的思想，与 egg 相比分别跟 springboot 和 springmvc 类似

- Node 中间件的实现原理: [发布订阅：use、handle、next、queue]
  ```
    class App {
      queue: [],
      use(cb) { this.queue.push(cb) },
      handle(ctx) {
        const next = () => {
          const cb = this.queue.shift()
          if (cb) cb(ctx, next)
        }
        return next()
      }
    }
  ```

- Node 启动流程简述: [初始化(v8、libuv)、加载依赖模块(核心模块、用户模块)、事件循环]
  1. 解析命令行参数
  2. 初始化 Node.js 环境：初始化 V8 引擎、libuv(事件循环、线程池)、全局对象(global、process 等)。
  3. 执行预加载模块（如果有）
  4. 加载并执行入口脚本
  5. 处理模块依赖：依次访问模块缓存、核心模块、用户模块。
  6. 执行异步操作：执行脚本的过程中，若遇到异步操作，则调用相应线程，在合适的时机将回调推入事件队列。
  7. 进入事件循环：轮询并清空事件队列。
  8. 退出进程

- 