## new / bind / call / apply
  1. 关键在于 this 的处理

## 继承
  1. 目的: 每个子类的实例 都可以 拿到 父类的 原型属性 和 实例属性
  2. 子类call父类 + 子类持有父实例
  ```
    function Parent() {}

    function Son(...args) {
      Parent.call(this, ...args); // 让 父类 也能拿到入参
    }

    Son.prototype = new Parent(); // 拿到 父类的 原型属性 和 实例属性
  ```
## promise
  1. 发布订阅: 发布订阅模式，then/catch 注册回调，resolve/reject 时触发回调
  2. 延迟执行: 延迟 resolve/reject 到下个事件循环，以让 then() 在 resolve() 前生效
  3. 链式调用: 
    执行器: resolve / reject 接受参数，为 下一个 promise._value 赋值，同时修改当前 promise 的 state
    更新器: onFulfilled / onRejected 修改上一个 执行器 传下来的参数
    以链表的形式，每个promise在 callbacks 中持有下个 promise 的 更新器 和 执行器
    promise 在自身状态变化后调用 下一个 promise 的更新器，获取 处理后的数据，并作为下一个 promise 执行器的入参
  4. 边界处理: 
    1. 更新器 返回值是一个 promise
      此时 更新器的返回值 不能直接作为 下一个 执行器 的入参，需要先取得该 promise 已决后的 value
      要取得 promise 已决后的 value，最简单的方法就是 调用他的then，注册一个 临时监听器
      关键在于 临时监听器 拿到 已决后的 value，怎么传递给 后面的 监听器
      将 临时监听器 的 监听对象 称为 发布者，后面的 监听器，原先是在 发布者 的 callbacks 中存入了 自身的 执行器，供 发布者 已决后 调用
      那么，只需要在 临时监听器 状态变化时，执行 监听器注册在发布者中的 执行器即可
      那么，最简单的方法是什么呢，再执行一边 发布者 的执行器，他会自动调用订阅了自己的 订阅者的执行器
    2. 更新器 缺失
      链式调用中，某个 listener 没有通过 then 注册 更新器 时，直接调用 listener 的执行器
  ```
    function MPromise(fn) {
      let state = 'pending';
      let _value = null;
      const callbacks = []; // 收集 监听当前Promise变化 的 订阅者

      // 订阅, 将自身的 执行器/更新器 存入 发布者 的 callbacks
      this.then = function (onFulfilled, onRejected) {
        /**
         * onFulfilled / onRejected 更新器, 修改上一个 resolve 传下来的值
         * resolve / reject 执行器, 修改当前 promise.state, 并给下一个 promise._value 赋值
         */
        return new MPromise(function (resolve, reject) {
          handle({
            onFulfilled,
            onRejected,
            resolve,
            reject,
          });
        });
      };

      /**
       * 负责处理 订阅者
       * 若当前 promise 未决, 则将 订阅者 放入队列, 等待 状态变化
       * 当前 promise 状态变化后, 调用 订阅者 的 执行器, 将当前的 _value 传递过去
       */
      function handle(listener) {
        // 当前状态 Promise 是 未决态, 则加进 当前 Promise.callbacks 中
        if (state === 'pending') {
          callbacks.push(listener);
        } else {
          // 当前状态 Promise 是 已决态, 则 先调用更新器 修改 传给下一个 promise 的值
          const updater = state === 'fulfilled' ? listener.onFulfilled : listener.onRejected;
          const executer  = state === 'fulfilled' ? listener.resolve : listener.reject;
          let nextPromiseValue = _value;
          if (updater) {
            /**
             * 更新器 的返回值有两种情况, 将决定下一个 执行器 的入参, 执行器(resolve) 中需要考虑到这种情况
             * 1. 非 promise, retrun 值直接作为下一个 resolve 的入参
             * 2. promise, 下一个 resolve 的入参 取已决态的 promise._value
             */
            nextPromiseValue = updater(_value);
          }
          executer(nextPromiseValue);
        }
      }

      // 链式调用的执行者, 其接受的值, 将作为 当前 Promise 的 最终value, 并传递给下一个 Promise
      function resolve(valueOrPromise) {
        if (valueOrPromise instanceof MPromise) {
          /**
           * 此时 更新器的返回值 不能直接作为 下一个 执行器 的入参, 需要先取得该 promise 已决后的 value
           * 要取得 promise 已决后的 value, 最简单的方法就是 调用他的then, 注册一个 临时监听器
           * 关键在于 临时监听器 拿到 已决后的 value, 怎么传递给 后面的 监听器
           * 将 临时监听器 的 监听对象 称为 发布者, 后面的 监听器, 原先是在 发布者 的 callbacks 中存入了 自身的 执行器, 供 发布者 已决后 调用
           * 那么, 只需要在 临时监听器 状态变化时, 执行 监听器注册在发布者中的 执行器即可
           * 最简单的方法是 再执行一边 发布者 的执行器, 他会自动调用订阅了自己的 订阅者的执行器
           */
          valueOrPromise.then(resolve, reject);
        } else {
          state = 'fulfilled';
          _value = valueOrPromise;
          exec();
        }
      }

      function reject(reason) {
        state = 'rejected';
        value = reason;
        exec();
      }

      function exec() {
        setTimeout(function () {
          callbacks.forEach(function (listener) {
            handle(listener);
          });
        }, 0);
      }

      fn(resolve, reject);
    }
  ```
## 防抖/节流
  ```
    function lazy (cb, delay) {
      let last = Date.now();
      let timer;
      return (...args) => {
        const now = Date.now()
        let done = false;
        // 节流
        if ((now - last) > delay) {
          last = now;
          done = true;
          cb.apply(null, args)
        }
        // 防抖
        if (!done) {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => {
            cb.apply(null, args) 
          }, delay)
        }
      }
    }

    window.addEventListener('scroll', lazy(()=>{console.log(1)},500))
  ```
## 深拷贝
  1. 基本类型直接返回
  2. 引用类型依据 Array.isArray 确定返回类型，遍历属性递归
  3. 缓存访问过的引用类型，再次访问时直接返回，以避免循环引用
  ```
    function deepClone(source, cache = []) {  // cache 可以改用 weakmap
      // 基本类型直接返回
      if (source === null || typeof source !== 'object') return source;

      // 用哈希表缓存已出现的属性, 解决循环引用
      const hit = cache.find(v => v === source)
      if (hit) return hit;
      cache.push(source);

      // 递归处理
      const result = Array.isArray(source) ? [] : {};
      Object.keys(source).forEach(k => { // 如果是for in循环择要考虑原型属性, 用hasOwnProperty判断
        result[k] = deepClone(source[k], cache);
      })
      return result
    }
  ```
## 函数柯理化
  1. 实现 composeFn([fn1,fn2,fn3])(10)
    ```
      const fn = a => a + 1 
      function composeFn(fns) {
        return function (params) {
          let result = params
          fns.forEach(f => result = f(result))
          return result
        }
      }
      composeFn([fn,fn,fn])(10) // 13
    ```
  
## 数字的千分位显示
  