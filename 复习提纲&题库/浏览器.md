## 基础: 进线程的概念
  1. 计算机系统 = CPU + 存储器 + IO https://www.cnblogs.com/tiankong101/p/4229584.html
    1. CPU 只负责对 输入的指令 和 数据 进行计算
    2. 而 计算哪些指令和数据 由 操作系统 通过 调度算法 来分配
    3. 早期为了单核CPU能 '同时' 运行多个任务，引入了进程(启动一个应用即创建一/多个进程)，通过不断切换进程来实现 并发
    4. 维护进程需要 页表(虚拟内存)、文件描述符、寄存器(运行时数据)、信号(进程运行信息) 等信息，开销较大
    5. 为了减小开销，引入了线程，线程可以理解为拥有资源(寄存器、栈等)的函数 (如 Java 中 vm 会为 main函数 创建一个线程)
    ```
      假设一个场景，需要发送100条请求获取数据，计算各自的md5值后拼接在一起
      如果没有进程，则CPU需要等待所有请求返回后再计算，CPU空闲等待的时间很长，利用率低
      如果采用了多进程分别处理每条请求，算出md5后发送给 主进程(拼接)，则进程的创建和切换开销较大
      如果采用多线程处理每条请求，则提高了CPU利用率的同时，也避免了不必要的开销
    ```

  2. CPU、进程、线程 (CPU同时只能执行一个进程，一个进程可以拥有多个线程协同工作)
    1. 进程是 OS资源分配(计算资源+内存) 的单位，每个进程拥有 独立地址空间，进程间交换数据需要通过 管道、信号、套接字 等方式通信
    2. 线程是 OS资源调度 的单位，一个进程可以包括多个线程，线程间依赖且共享同一进程中的内存
    3. 一个应用执行至少需要一个进程和一个线程，执行中可以创建其他线程
    4. 抽象的例子 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html
    5. 协程 轻量级线程，区别于线程由内核调度，协程的调度由应用层定义，依赖于线程的资源 https://cloud.tencent.com/developer/article/1517549

## 浏览器的进/线程
  1. 浏览器四大进程 (浏览器主进程、渲染进程(浏览器内核)、GPU进程、插件进程) https://zhuanlan.zhihu.com/p/47407398?from_voters_page=true
    1. 浏览器主进程: 负责统筹协调 渲染进程 的创建和销毁、位图绘制 (在硬件允许的情况下，主进程中的下列 线程 将 独立创建进程，以提供工作效率)
      1. UI线程: 负责 用户交互(前进后退)、地址栏输入等
      2. 网络线程: 负责网络请求，如 DNS查询、TCP/TLS连接等
      3. 存储线程: 负责文件I/O
    2. 渲染进程: 每个tab页都会创建一个 渲染进程，负责 DOM/CSS解析、脚本执行、事件处理、位图生成 等，其包含5种线程
      1. GUI 线程: 
        负责html/css解析、构建DOM树与render树
        如果遇到 script 标签，将暂停解析，移交控制权至 JS引擎线程，待其完成执行后继续解析
      2. JS引擎 线程: 
        JS脚本执行过程中，如果遇到 为DOM绑定事件、setTimeout/setInterval、ajax，分别调用对应线程辅助，在 符合触发条件 时将 回调 推入 事件队列
        JS引擎轮询事件队列，如果有回调，则取出执行
      3. 事件触发 线程
      4. 定时器触发 线程
    3. GPU进程: https://jishuin.proginn.com/p/763bfbd671c2
      常用于3D绘制，video、canvas的加速也得利于GPU
      图层提升 被放在GPU中进行，以减少 GUI线程 争抢 JS执行资源，使得 CSS动画 在 JS阻塞的情况下 依然流畅
    4. 插件进程: 仅用于浏览器插件
  
  2. 提问
    1. 事件循环与浏览器帧的关系
      浏览器一帧可能执行多次事件循环，这一点可以通过循环调用 setTimeout、requestAnimationFrame 来证实
      辅助线程 会根据当前帧的执行情况，决定在当前帧还是下一帧将回调推入事件队列(因为需要留出时间用于GUI绘制)
      ```
        let num = 0
        function timer(now) {
          num++;
          if (num > 500) return;
          setTimeout(() => {
            const _now = Date.now()
            console.log('timer', _now - now)
            timer(_now);
          }, 0)
        }
        timer(Date.now())

        let num2 = 0
        function tick(now) {
          num2++;
          if (num2 > 500) return;
          requestAnimationFrame(() => {
            const _now = Date.now()
            console.log('tick', _now - now)
            tick(_now);
          })
        }
        tick(Date.now())

        let num3 = 0
        function idle(now) {
          num3++;
          if (num3 > 500) return;
          requestIdleCallback(() => {
            const _now = Date.now()
            console.log('idle', _now - now)
            idle(_now);
          })
        }
        idle(Date.now())
      ```
    2. 每一轮事件循环都会重新渲染吗
      不一定，但每一帧都会重新渲染(除非被长时间的同步JS阻塞)
    3. timer 和 raf 的区别
      timer 是 渲染进程 中的 定时器 线程控制的，raf 是 浏览器主进程 控制的
      当tab不活跃时，timer是会持续执行的(虽然频率降低了，这与刷新频率有关)，但 raf 和 idle 是不执行的

## node中的进线程 https://blog.csdn.net/weixin_39572409/article/details/110105835

## 浏览器 渲染进程 工作流程 https://blog.csdn.net/weixin_45820444/article/details/109013996
  1. 构建DOM树: 解析html片段, 进行词法分析、语法分析得到AST, 并据此构建DOM树
    1. JS阻塞DOM解析: 因为JS可能修改DOM结构，因此构建过程中遇到 script 标签将暂停解析，等 JS引擎 完成执行后继续解析
      async 属性可以改为异步加载，加载完成后立即执行，defer 属性可以让 script 在DOM构建完后执行
    2. CSS阻塞DOM渲染:
    3. CSS阻塞JS加载: 因为 js 可以操作样式，这使得 js 执行需要完整的 CSSOM，变相地导致 css计算 阻塞 DOM构建
  2. 计算css: 为DOM树的每个节点计算css属性, 得到一份 CSSOM(CSS对象模型) https://www.w3cplus.com/javascript/cssom-css-typed-om.html
  3. 排版: 确定每个DOM节点在屏幕上的物理位置
  4. 将排版后每个元素 各自的盒模型 渲染成 位图, 这个过程不包括子元素, 以确保父子元素相对位置改变时能够利用缓存的结果
  5. (合成): 为了性能考虑, 将部分子元素渲染到父元素的位图中
    transform
    will-changes

## 浏览器工作原理
  1. 浏览器帧的工作流程
    1. 处理用户交互
      blocking input event
        touch wheel
      non-blocking input event
        click, keypress
    2. 执行JS脚本
    3. 开始帧
      window resize
      scroll
      mediaquery changed
      animation event
    4. requestAnimationFrame 回调，适合做动画，因为JS动画可能导致一帧内多次绘制，造成浪费
    5. 重新计算样式, 生成布局树, 生成渲染列表
    6. requestIdleCallback
      当16ms内完成了一帧内的任务, 则会有空余时间, 执行 requestIdleCallback 里注册的任务
      widnow.requestIdleCallback((IdleDeadline) => {}, { timeout: 2000 })
        timeout 若一直没有等到空闲时间, 则在指定时间后强制执行
        IdleDeadline.didTimeout 表示任务是否超时
        IdleDeadline.timeRemaining() 表示当前帧剩余的时间
      因为 requestIdleCallback 的执行在DOM渲染之后, 此时不宜操作DOM, 否则引起回流, DOM操作应该放到 requestAnimationFrame

## 重绘 / 回流
  1. 回流: GUI线程 重新 构建DOM树-计算样式-排版-渲染
    对dom结构的修改(width/height/margin/padding/left/top/border等)引发尺寸变化
    增/删/移动 DOM节点
    读写offset、scroll、client等属性时, 浏览器为了获取值也需要回流
    调用 getComputedStyle / getBoundingClientRect 方法
  2. 重绘: 仅 计算css 和 渲染
    样式变化且不影响尺寸
  3. 总结:
    尽量修改class而不是style
    批量操作DOM (操作脱离文档流的部分仅会引起部分回流)  事实上, 较新的浏览器在这方面自带优化, 会缓存多次DOM操作在一次回流中执行
      可以先隐藏修改后再显示
      可以使用 createDocumentFragment 构建DOM子树, 进行批量的 DOM 操作后放回文档
    避免触发同步布局(即先写后读, 减少offset、scroll、client等属性的重复读取)
    对于 resize、scroll 等进行防抖/节流处理

## 跨tab通信 https://mp.weixin.qq.com/s/GyQn922lTmpILmAi05xNOQ
  1. localStorage 方案
    原理: localStorage 修改变时会触发 storage 事件，可通过 addEventListener("storage") / onstorage 感知
    特性: 
      1. localStorage.setItem 的tab无法感知本次变化
      2. 只有值发生变化才会触发事件
      3. 需要同源

  2. postMessage 方案
    原理: 具有依赖关系的窗口可以拿到对方的引用，调用该引用的 postMessage 方法可以触发其 message 事件
    特性:
      1. 两个页面需要有依赖关系，如 A window.open 打开了 B，或 iframe 与主页面的通信
      2. postMessage 的第二个参数可以指定接收方的域名，'/' 代表同源，'*' 所有页面
  
  - iframe 方案
    原理: tab A 和 B 分别嵌入 iframe，引用相同的 html 文件，记为 fA,fB，tA与fA、tB与fB 通过postMessage通信，而fA和fB同源，通过storage通信
    特性: 
      1. 可以在两个无关联的tab页中通信，无需依赖关系和同源

  - BroadcastChannel 方案
    原理: 两个tab各自创建 BroadcastChannel 实例，发送方调用 postMessage 可以被接收方的 onmessage 感知
    特性: 同名、同源

  - cookie 方案
    原理: tab间共享cookie，但需要轮训监听变化，且会被当成冗余数据发到服务端，不建议使用

## 本地存储
  cookie: 字符串形式, 请求发起时自动加入请求头, 有效期由服务端设定, tab间共享, IE6+
  localStorage: 键值对形式, 持久保存, tab间共享, IE8+
  sessionStorage: 键值对形式, tab存在期间有效, tab间独立, IE8+
  --indexDB/WebSQL: 兼容性差, 没用过

## 题库
- 从url输入到展示的过程
  1、浏览器构建请求, 根据是否强缓存确定是否发送请求
  2、DNS解析, 由域名得到IP地址
  3、建立TCP连接
    三次握手建立连接
    数据传输(接收方需确认, 否则发送方认为数据包丢失重新发送)
      浏览器发送http请求(请求头/请求体)
      服务器响应http请求(响应头/响应体)
    四次挥手断开连接(若请求头或响应头中的Connection为Keep-Alive则不立即断开, 后续的请求资源会继续使用)
  4、浏览器解析html并渲染 (DOM树 -> 渲染树 -> 布局树)
    渲染引擎 解析html, 构建DOM树: 
      标记化算法(词法分析) < [a-z] > data < [a-z] />
      建DOM树(语法分析), 建树的过程中会将请求传递给网络线程下载次级资源(图片、js、css等)
        在这个过程中, 当遇到 "<script>" 时, html 解析会暂停转而先执行js, 因为其可能改变 DOM 结构, 重新生成 DOM树
        因为js在样式没有加载完前获取样式信息会导致获取错误, 因此样式的加载会阻塞JS的执行(chrome中仅操作样式的部分会阻塞)
      执行 defer 属性的js脚本, 文档的状态修改为 "complete", 同时触发一个 "load" 事件 (即 "<script defer=true>" 不会阻塞页面, "<script async=true>" 异步加载脚本也不会阻塞)
    渲染引擎 解析样式文件, 计算样式(为每一个DOM节点计算样式), 生成样式表: 
      格式化
      标准化: 将red转为#ff000, bold装为700等
      继承和层叠
    生成布局树: 遍历DOM树的节点, 根据样式表计算节点相对于页面的坐标位置(display: none 的节点在布局树不可见, 在DOM树中不可见的伪元素在布局树中可见)
    构建图层树: 对特定的节点(如动画、层叠上下文等)进行分层, 即绘制的顺序, 层级低的先绘制
      创建图层: 层叠上下文、添加了 will-change 的CSS属性
      每个图层(有自己的绘制列表)都会单独发送给合成器线程, 合成器不与主线程冲突(不需要等待css、JS), 有图层的动画更流畅(回流时仅回流本层)
    生成绘制列表, 即根据渲染顺序拆分成渲染指令(画背景、画边框等), 制定渲染流程
      提交给合成器线程, 生成图块(仅绘制浏览器窗口大小的部分), 图块栅格化生成位图数据, 发送给显卡显示在浏览器中
    重排会导致 布局->分层->绘制->合成->显示, 重绘会导致 绘制->合成->显示



## 待整理 https://blog.csdn.net/weixin_42476799/article/details/102893692
  - 宏任务 -> 微任务 -> requestAnimationFrame -> 渲染 -> requestIdleCallback

  - 案例1: 
  ```
    for (var i= 0; i< 100; i++) {
      requestAnimationFrame(() => { console.log(1) })
      requestIdleCallback((r) => { console.log(2, r.timeRemaining()) })
    }

    执行结果
      100 1
      2 5.3
      2 5.2
      ...
      2 50.0
      2 49.9
      ...

    现象: 
      1. 在第一个 idle 执行前，所有的 raf 都已经执行完了
      2. idle 返回的时间逐渐减小到0
      3. idle 返回的时间，最大值不一定是16，可能很大(48)，也可能很小(12)
      
    解释: 
      1. requestIdleCallback 的帧率只有20，这也是为什么剩余时间最大能达到 约50ms 的原因
      2. 
  ```

  - 案例2:
  ```
    var i = 0;
    function frame () {
      i++;
      requestAnimationFrame(() => {
        console.log(i)
        if (i < 100) frame();
      })
      requestIdleCallback(r => console.log('idle', r.timeRemaining()))
    }
    frame();

    执行结果

    1
    idle 1.1
    idle 1
    2
    idle 15.4
    3
    idle 15.5
    4
    ...

    现象:
      1. 第一次 raf 回调执行后，打印了两次 idle
  ```

  分析结论:

const body = document.querySelector('body')
let num = 0
function fn (now) {
  num ++
  if (num > 50) return;
  const _now = Date.now() - now;
  console.log('cyk', _now)
  //body.getBoundingClientRect()
  fn(_now);
}
fn(Date.now());