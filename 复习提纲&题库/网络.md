## dns: 域名 -> ip https://blog.csdn.net/yipiankongbai/article/details/25031461
  1. 域名等级 www.baidu.com
    根域名: 域名末尾的. , 系统层面的兼容，不需要输入
    顶级域名: com
    二级域名: baidu
    三级域名: www
    本地域名服务器
    每层域名都有域名服务器负责存储 域名 与 ip 的映射

  2. 域名缓存
    浏览器缓存: 浏览器会缓存请求过的ip，以减少dns的解析次数
    操作系统缓存: hosts 文件

  3. 解析过程
    1. 缓存阶段: 查询 浏览器 和 操作系统层面 的缓存
    2. 本地域名服务器查询: 若查到则返回，若未查到则求助 根域名服务器，代替客户主机发送后续请求
    3. 迭代查询: 根服务器 不直接返回ip给 本地服务器，而是返回 顶级服务器 的ip，让他们再次通信，依次类推

  4. 优化方案
    1. dns 预解析: 让浏览器对 后续可能访问的网站 提前进行DNS解析
      <meta http-equiv="x-dns-prefetch-control" content="on" /> 开启预解析
      <link rel="dns-prefetch" href="www.test.com" /> 对指定域名做解析

    2. cdn 技术: 在距离用户地理位置近的 DNS服务端 缓存域名解析结果

## cdn: 将 内容 缓存在 用户附近
  1. 作用: dns解析加速 + 负载均衡
    dns解析加速: 根据用户位置分配最近的资源, 减少了DNS寻址的次数
    负载均衡: 选择距离近且有能力提供服务的服务器

  2. 作用流程
    1. 用户提交域名，浏览器解析域名
    2. DNS解析，返回CNAME别名，而不是IP地址
    3. 本地DNS向负载均衡系统再次发送请求，进行 调度
      调度的原则主要有
        用户IP地址附近
        用户网络运营商相同
        负载情况较轻 (同时访问的人数少)
        边缘节点的 带宽、响应速度等因素
    4. 常用的资源会被缓存在 边缘节点中，衡量其服务好坏的指标是 命中率/回源率，通过多层缓存，可以有效降低回源率

## TCP
  1. 主要报文字段
    Seq 序号
    Ack 确认号
    SYN 发起新连接
    ACK 确认序号有效
    FIN 释放连接
    RST 重置连接

  2. 握手过程
    客户端 -> 服务端: [SYN] Seq=x                // 询问是否可以建立连接
    服务端 -> 客户端: [SYN, ACK] Seq=y Ack=x+1   // 回复请求已收到, 同意建立连接
    客户端 -> 服务端: [ACK] Seq=x+1 Ack=y+1      // 确认数据传输正常, 尝试建立连接

    若使用两次握手, 当服务端的确认报文丢失时, 服务端已开始传输数据, 而客户端认为连接尚未建立, 导致传输无效

  3. 挥手过程
    客户端 -> 服务端: [FIN, ACK] Seq=x           // 请求释放连接, 停止向服务端发送非报文数据, 但仍可接收
    服务端 -> 客户端: [ACK] Seq=y Ack=x+1        // 回复请求已收到, 同意释放连接
    服务端 -> 客户端: [FIN, ACK] Seq=z Ack=x+1   // 回复准备就绪, 可以释放, 停止向客户端发送非报文数据, 但仍可接收
    客户端 -> 服务端: [ACK] Seq=x+1 Ack=z+1      // 确认准备就绪

    握手时服务端接收到请求无需做准备, 可立即开始建立连接
    挥手时, 服务端需要做一些必要的数据处理(比如数据未传完), 不能立即关闭连接, 因此需要两次回复来确认

## websocket
  1. 建连过程
    1. 客户端发送一条http请求，请求头设置
      Connection: Upgrade
      Upgrade: websocket
      Sec-WebSocket-Key: base64编码的密文，用于认证密钥，要求服务端返回 Sec-WebSocket-Accept
      
    2. 服务端返回 101 Switching Protocol 表示切换协议，连接建立完成

  2. 对比 http 的优势
    优势
      1. 双向传输，服务端可以主动推送
      2. 没有http头等附加信息，数据量小
      3. 鉴权只发生在建连时，传输时不需要 (即有状态，对标http的无状态)
    劣势
      1. 不能使用浏览器缓存
      2. 刷新浏览器需要重新连接

## http 报文
  1. http 报文的组成
    请求行: get /login http/1.1 
    请求头: 以 ; 分割的多个键值对 
    请求体: 

    状态行: http/1.1 200 Ok
    响应头: 以 ; 分割的多个键值对 
    响应体: 

  2. 常见状态码
    101: 切换协议, 如websocket
    200: 请求成功
    204: 预请求，服务端不返回响应体，常用于测试接口是否可用
    206: 还有后续请求
    301/302: 请求临时/永久重定向
    304: 资源未修改, 客户端使用缓存数据
    400: 参数错误
    401: 权限需验证
    403: 权限有误，服务器拒绝执行
    404: 不支持的请求(未找到资源)
    500: 服务器异常, 如空指针
    502: 网关错误

## http 版本
  1. http 1.0: 一次http请求需要 建立/断开一次tcp连接
  2. http 1.1:
    1. 缓存策略
    2. 持久连接: keep-alive 头
      作用: 一个tcp可以多次传送http报文
      局限: 一个tcp上的多个http必须串行发送，不能重叠，浏览器对同时存在的tcp数量有限制，chrome是6个
    3. host 头: 请求头和响应头必须包含，以区分同一物理机的不同虚拟主机的域名
  3. http 2.0:
    1. 帧传输/多路复用: 多个http请求可以在一个tcp上并发进行，传输内容被分成多个二进制帧，内置标识符
    2. 头部压缩: 静态字典+动态字典，通过映射的方式 请求头和响应头被压缩并缓存，减少传输长度
    3. 服务器推送: 应该理解为预加载，将静态资源发送给客户端，利用缓存特性减少http请求次数
    
    缺点:
      1. 如果丢帧会等待重传，阻塞后续数据
      2. 可能导致瞬时的请求量增加，服务器压力变大

## https https://zhuanlan.zhihu.com/p/96494976
  1. https 和 http 的区别
    1. 端口: http 使用80端口，https 使用443
    2. 安全性: 
      http 明文传输，安全性依赖对称、公私钥、混合加密等手段，但存在被中间人 截获密钥、模拟服务器 的可能
      https 运行在ssl上，采用公私钥加密，通过ca证书确认客户端收到的公钥来自服务端而不是中间人
    3. 所处层: http (应用层) 运行在 tcp (传输层) 上，https运行在 tcp 之上的 SSL/TLS (应用层与传输层之间) 上

  2. https工作过程
    1. 认证站点: 客户端发起https请求，返回数字证书，通过证书 验证访问的网站是想要的站点 (避免中间人攻击)
      1. 数字证书: 服务端公钥、ca机构签名、服务端信息
      2. 认证过程: (确认访问的网站是想要的站点)
        1. 前提: 如果 证书签名 的是权威机构，则认为是合法的
        2. 每份证书都包含了其是 哪家机构 认证的，这是链式的
        3. 判断证书是否被篡改 需要与 CA机构 通信校验，其保存了自己签发过的所有证书，可以逐一比对

    2. 协商密钥: 协商 本次会话的对称加密密钥，用于下一阶段的加密传输
      1. 生成随机数 (作为后续数据对称加密的密钥)，通过 服务端公钥 加密，传给服务端
      2. 服务端用私钥解密出 随机数(对称加密密钥)
      3. 这一步可以防止证书被冒用，因为中间人只能从证书中拿到公钥，而不知道服务端私钥，因为无法解密出 对称密钥

    3. 加密传输: 基于2得到的密钥对数据进行 对称加密 (注意是对称加密，非对称加密只在 证书认证阶段)
      1. 采用对称加密的原因是 效率高
      2. 因为每次SSL连接 都会产生新的 对称加密密钥，即便泄漏也不会造成安全问题

  3. https优缺点
    1. 比http安全，其保障了传输安全，在用户不主动授信的情况下，抓包得到的都是密文
    2. 比http耗时，因为多了证书认证、密钥协商、加解密等阶段
    3. SSL证书成本高，自建的证书会被浏览器提示风险

## 缓存 强缓存 + 协商缓存 https://juejin.cn/post/6844903473268391943
  1. 强缓存(Expires / Cache-Control): 若符合强缓存条件, 则不重新发起请求
    http1.0 通过Expires设置资源过期时间, 如未过期则不重新发起请求(可能存在服务器和客户端时间不一致的情况, 被抛弃了)
    http1.1 Cache-Control: max-age=3600 设置资源在多少秒后过期, 0则表示禁用强缓存 (等同于 no-cache)
    Cache-Control: no-cache 将跳过强缓存, 进入协商缓存阶段

  2. 协商缓存 (Last-Modified / ETag)
    Last-Modified: 服务器返回资源时在响应头中加入 Last-Modified 表示更新时间, 作为浏览器再次请求时的 If-Modified-Since 值, 服务端再根据该值与资源最后修改时间做对比, 若等于最后修改时间则返回304, 否则返回新资源并修改 Last-Modified
    ETag: 与 Last-Modified 类似, 服务端每次修改文件都会为其重新生成唯一标示, 通过响应头发给浏览器, 并作为 If-None-Match 的返回值
  
  3. 执行过程
    1. 浏览器构建请求，若命中强缓存规则(未过期)，则不发起请求
    2. 浏览器携带 资源修改信息 发送到服务端，服务端判断资源是否更新过，如未更新过则返回 304
    3. 若资源已更新，则返回新资源并更新 资源修改信息 
    
  4. 禁用缓存: 
    (1) 请求头设置 Cache-Control: no-store
      Cache-Control 是金字塔顶尖的规则, 将覆盖其他设置, 他是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置
    (2) 设置 ETag: If-None-Match, 比 Last-Modified 优先级高 
    (3) 请求头将 If-Modified-Since 设为 0
      原理: 服务端返回资源时会在响应头中加入 Last-Modified 表示更新时间, 若浏览器发起请求时携带的 If-Modified-Since 与 Last-Modified 相同则服务端返回304, 否则返回新资源并修改 Last-Modified 
    (4) 在url中加时间戳: 浏览器会认为他是一个新的请求, 从而不在请求头里加 If-Modified-Since
    (5) 设置 http-equiv: <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
      此方法有兼容性问题, 且因为代理服务器不解析HTML, 也不支持

## 跨域
  1. 跨域的产生条件: 浏览器的同源策略，即 协议、域名、端口 不同都被认为跨域
  2. 解决方案
    1. 反向代理: 服务端没有跨域，因此可以通过代理服务器 对服务端隐藏客户端身份，转发请求
    2. JSONP: 带src属性的标签, 不受同源策略的影响
      1. 客户端定义 回调函数，以 参数形式 将函数名写在动态创建的 script 标签的 src 中
      2. 服务端接受到请求后，从url中拿到 回调函数名 cb，将 data 作为执行函数的实参，向客户端返回 `cb(data)`，浏览器会执行这段脚本
      3. JSONP 只能用于get请求
    3. CORS: 服务端设置Access-Control-Allow-Origin即可, 前端无须设置, 若要带cookie请求, 前后端都需要设置（服务端解决方案）
    4. document.domain + iframe跨域: 两个页面都通过js强制设置document.domain为基础主域, 就实现了同域
    5. location.hash + iframe跨域: a欲与b跨域相互通信, 通过中间页c来实现。 三个页面, 不同域之间利用iframe的location.hash传值, 相同域之间直接js访问来通信
    6. window.name + iframe跨域: 通过iframe的src属性由外域转向本地域, 跨域数据即由iframe的window.name从外域传递到本地域
    7. postMessage跨域: 可以跨域操作的window属性之一, 但必须是父子关系的窗口

## 网络攻击 https://mp.weixin.qq.com/s/awf6cC3HvWDre-yZWg6Oeg
  1. 中间人攻击: 同时模拟客户端和服务端行为，两头骗取密钥信息
    1. 通过DNS劫持，对客户端发放 中间人公钥，之后可以解密出 客户端发来的数据
    2. 转发请求到服务端，拿到 服务端公钥，用于给客户端数据加密

  2. CSRF: 跨站请求伪造
    1. 主要利用了 cookie 在浏览器tab间共享，诱导用户跳转以拿到 cookie 中的认证信息
    2. 防范的主要手段，可以用其他 本地存储方案 存储重要信息，在请求头中传递

  3. XSS: 跨站脚本攻击
    1. 原则就是不相信用户的输入，对输入进行转译

## 题库
- 为什么握手是三次, 挥手要四次？
  握手时服务端接收到请求无需做准备, 可立即开始建立连接；挥手时, 服务端需要做一些必要的数据处理(比如数据未传完), 不能立即关闭连接, 因此需要两次回复来确认

- 为什么需要三次握手, 能否只用两次？
  若使用两次握手, 当服务端的确认报文丢失时, 服务端已开始传输数据, 而客户端认为连接尚未建立, 导致传输无效

- get 和 post 的区别
  从http报文看，没有太大差别，仅仅是 请求行中的类型 和 参数存放的位置不同
  但因为浏览器的实现，get和post的行为会有差异，如
    get的url有长度限制
    get可以被缓存、回退时不重新提交请求
    get只能传ASCII字符，post可以传二进制
    get的参数会被存放于url，相对来说安全性更差
