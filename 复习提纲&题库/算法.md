## 快速排序 https://www.runoob.com/w3cnote/quick-sort.html
  1. 从数组中选定 基准值，遍历数组，将大于基准值的数 移到 基准值右边，将小于他的数移动到左边
  2. 对左右分区重新执行步骤1

  实现1: 
  ```
    function quickSort (arr) {
      if (arr.length <= 1) return arr;

      // 找基准值
      const pivotIndex = Math.floor(arr.length / 2);
      const pivot = arr[pivotIndex];

      // 分别存放比基准值 小/大 的数据项
      const left = [];
      const right = [];

      // 遍历比较
      for (let i = 0; i < arr.length; i++) {
        if (i === pivotIndex) continue;
        if (arr[i] <= pivot) {
          left.push(arr[i]);
        } else {
          right.push(arr[i]);
        }
      }

      // 二分递归
      return [...quickSort(left), pivot, ...quickSort(right)];
    };
    quickSort([2, 4, 5, 6, 3, 7, 8])
  ```
  分析: 时间复杂度 O(nlogn), 空间复杂度 O(n), 因为用了数组存放 左右分区

  实现2: 双指针
  ```
    function swap(A, i, j) {
      const t = A[i];
      A[i] = A[j];
      A[j] = t;
    }

    function divide(A, p, r) {
      const x = A[r - 1];
      let i = p - 1;

      for (let j = p; j < r - 1; j++) {
        if (A[j] <= x) {
          i++;
          swap(A, i, j);
        }
      }

      swap(A, i + 1, r - 1);

      return i + 1;
    }

    function qsort(A, p = 0, r) {
      r = r || A.length;

      if (p < r - 1) {
        const q = divide(A, p, r);
        qsort(A, p, q);
        qsort(A, q + 1, r);
      }

      return A;
    }

    qsort([2, 4, 5, 6, 3, 7, 8])
  ```

## 回溯算法: 常用于穷尽排列组合
  本质上是 深度优先 递归
  ```
    // 
    function fn(arr, limit) {
      const result = [];

      function helper(cache) {
        if (cache.length === limit) return result.push(cache.slice());
        for(let i=0; i<arr.length ; i++) {

        }
      }
      helper([]);

      return result;
    }
  ```