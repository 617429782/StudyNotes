## 总览
  代码规范 (eslint、prettier、git钩子)
  版本管理 (git)
  依赖管理 (npm/yarn/pnpm)
  打包 (webpack/rollup/vite)
  持续集成/部署 (CI/CD)
  异常监控 (sentry)
  性能监控 (performance)
  日志管理 
  链路追踪 
  埋点(用户行为收集)

## 依赖管理
  1. [npm](./npm.md)
  2. yarn 
  3. pnpm

## 持续集成/部署
  背景 https://mp.weixin.qq.com/s/0YkzINaR2wido8dOaRHjKA
  方案 https://mp.weixin.qq.com/s/c8P69DRy--kg8hgA8mQwvg

  1. 持续集成: 目的是将项目的集成分散到日常，减轻上线阶段的冲突、测试压力，更多是版本管理的策略
  2. 持续部署: 在持续集成的基础上，提供自动化部署脚本

  流程: 通过 gitlab 的 webhook 触发 jenkins job 的运行 https://zhuanlan.zhihu.com/p/26701038
    1. 本地完成开发提交代码, 触发 gitlab 的 webhook  https://www.cnblogs.com/xuxiaojian/p/14408859.html
      webhook 的原理是, 在开发者执行特定动作(如提交)时, 向 预先配置的url 发送一条 post 请求
      gitlab 会扫描项目中 .gitlab-ci.yml 文件
    2. webhook 触发 jenkins 的 构建 命令
    3. jenkins 从 git仓库 中 拉取代码, 运行 npm run build

## 性能监控
  1. 客户端性能监控 https://cloud.tencent.com/developer/article/1650831
    1. 关注指标
      1. 页面响应速度: 白屏时间、首屏时间、可交互时间
      2. 页面出错率: JS执行错误、资源加载错误
      3. 网络请求速度
    2. 监控方案 performance
    3. 优化方案

  2. node端性能监控 https://cloud.tencent.com/developer/article/1538673
    1. 关注指标
      1. CPU指标 os.cpus()
        CPU使用率(占用时间比): 1 - 空闲CPU时间(idle time) / CPU总时间
        CPU负载(进程数): 占用以及等待CPU的进程总数
      2. 内存占用率
        系统内存占用率 1 - freemem / totalmem
        ```
          const os = require('os');
          os.freemem(); // 获取系统空闲内存
          os.totalmem(); // 获取系统总内存
        ```
        node 内存占用率 heapUsed / heapTotal
        ```
          const { rss, heapUsed, heapTotal } = process.memoryUsage(); // 获取当前Node内存堆栈情况
        ```
      3. I/O
        磁盘 I/O 次数
        网卡 I/O 次数
      4. 网络
        QPS: 接口请求频率, 一般可通过 日志 统计, 压力测试可估算 流量峰值期间, 能够确保 响应时间合理 的 服务器数量
        RT: 响应时间

    2. 监控方案 
    3. 优化方案

## 