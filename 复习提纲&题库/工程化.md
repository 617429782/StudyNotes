## 总览
  代码规范 (eslint、prettier、git钩子)
  版本管理 (git)
  依赖管理 (npm/yarn/pnpm)
  打包 (webpack)
  持续集成/部署 (CI/CD)
  异常监控 (sentry)
  性能监控 (performance)
  日志管理 
  链路追踪 
  埋点(用户行为收集)

## 依赖管理
  - package.json https://mp.weixin.qq.com/s/VEByRtbk9umGsS7od2PPOg
    - bin: 可执行文件列表, 常用于 cli 工具, 会在被 install 后添加到 node_modules/.bin 和 PATH 文件中(全局安装时)
    - main / module / browser: 入口文件、ESM规范下的入口文件、浏览器环境下的入口文件
      - node 默认的 commonJS 规范要求使用 require + module.exports
      - ESM 规范使用 import + export，需要在 package.json 中声明 type: module
      - 相比 CJS，ESM 具有 引用输出、只读引入、import 提升 等特性，更有利 静态检查和tree-sharking https://juejin.cn/post/6844903861166014478
      - babel 通过修改赋值操作、同步修改 exports 值来模拟 只读引入和引用输出 的行为，但不能模拟 import 提升
    - dependencies: [常用三种依赖的区别](./npm.md#项目依赖)
    - files: 声明被 install 后，哪些文件在出现在宿主的 node_modules 里（通常不需要配置，打包环境基本上就已经处理好）
    - script
      - pre / post 在命令执行前后处理，如 { "start": "xxx", "prestart": "" }
    - version：[三级版本x修饰符](./npm.md#版本管理)

  - lock

  - npm https://blog.csdn.net/aojianmo2012/article/details/56300240

  - yarn
  
  - pnpm

## 持续集成/部署
  背景 https://mp.weixin.qq.com/s/0YkzINaR2wido8dOaRHjKA
  方案 https://mp.weixin.qq.com/s/c8P69DRy--kg8hgA8mQwvg

  1. 持续集成: 目的是将项目的集成分散到日常，减轻上线阶段的冲突、测试压力，更多是版本管理的策略
  2. 持续部署: 在持续集成的基础上，提供自动化部署脚本

  流程: 通过 gitlab 的 webhook 触发 jenkins job 的运行 https://zhuanlan.zhihu.com/p/26701038
    1. 本地完成开发提交代码, 触发 gitlab 的 webhook  https://www.cnblogs.com/xuxiaojian/p/14408859.html
      webhook 的原理是, 在开发者执行特定动作(如提交)时, 向 预先配置的url 发送一条 post 请求
      gitlab 会扫描项目中 .gitlab-ci.yml 文件
    2. webhook 触发 jenkins 的 构建 命令
    3. jenkins 从 git仓库 中 拉取代码, 运行 npm run build

## 性能监控
  1. 客户端性能监控 https://cloud.tencent.com/developer/article/1650831
    1. 关注指标
      1. 页面响应速度: 白屏时间、首屏时间、可交互时间
      2. 页面出错率: JS执行错误、资源加载错误
      3. 网络请求速度
    2. 监控方案 performance
    3. 优化方案

  2. node端性能监控 https://cloud.tencent.com/developer/article/1538673
    1. 关注指标
      1. CPU指标 os.cpus()
        CPU使用率(占用时间比): 1 - 空闲CPU时间(idle time) / CPU总时间
        CPU负载(进程数): 占用以及等待CPU的进程总数
      2. 内存占用率
        系统内存占用率 1 - freemem / totalmem
        ```
          const os = require('os');
          os.freemem(); // 获取系统空闲内存
          os.totalmem(); // 获取系统总内存
        ```
        node 内存占用率 heapUsed / heapTotal
        ```
          const { rss, heapUsed, heapTotal } = process.memoryUsage(); // 获取当前Node内存堆栈情况
        ```
      3. I/O
        磁盘 I/O 次数
        网卡 I/O 次数
      4. 网络
        QPS: 接口请求频率, 一般可通过 日志 统计, 压力测试可估算 流量峰值期间, 能够确保 响应时间合理 的 服务器数量
        RT: 响应时间

    2. 监控方案 
    3. 优化方案

## 